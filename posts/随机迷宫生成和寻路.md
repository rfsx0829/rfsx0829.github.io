---
title: 随机迷宫生成和寻路
tags:
  - Programming
  - C++
categories: C++
abbrlink: 19742
date: 2018-07-09 22:36:12
---
最近学习了一些数据结构相关的东西，想要多练练，于是写了个随机迷宫生成和自动寻路，为了实现可视化，使用了C++的easyx图形库

使用Kruskal算法生成迷宫，DFS搜索路径。

不多说，贴代码
```
// graphic.h
#include <algorithm>
#include <vector>
#include <stack>
#include <ctime>
#include <easyx.h>
#include <graphics.h>

#define LEN 20
#define NUM (LEN * LEN)
#define MAZELEN (LEN * 2 - 1)
#define LINELENGTH 40
#define WID (21 * LINELENGTH)

struct Point
{
	int x;
	int y;
};

class Gra
{
public:
	Gra();
	~Gra();
	bool connected(int a, int b);
	int find(int a);
	void unio(int a, int b);
private:
	int id[NUM];
};
```

```
// graphic.cpp
#include "graphic.h"

Gra::Gra()
{
	for (int i = 0; i < NUM; i++)
	{
		this->id[i] = i;
	}
}

Gra::~Gra()
{
	//donothing
}

int Gra::find(int a)
{
	int fa = this->id[a];
	while (fa != id[fa])
	{
		fa = id[fa];
	}
	return fa;
}

void Gra::unio(int a, int b)
{
	this->id[a] = b;
}

bool Gra::connected(int a, int b)
{
	int fa = this->find(a);
	int fb = this->find(b);
	if (fa != fb)
	{
		this->unio(fa, fb);
		int ai = a / LEN;
		int aj = a % LEN;
		int bi = b / LEN;
		int bj = b % LEN;
		line(ai * LINELENGTH, aj * LINELENGTH, bi * LINELENGTH, bj * LINELENGTH);
		return false;
	}
	return true;
}
```
```
// main.cpp
#include "graphic.h"

#define ROAD 0
#define WALL 1
#define STARTNUM 2
#define ENDNUM 3

int main(void)
{
	Gra *g = new Gra();
	std::vector<Point> tem;
	std::stack<Point> st;
	int maze[MAZELEN][MAZELEN];
	for (int i = 0; i < MAZELEN; i++)
	{
		for (int j = 0; j < MAZELEN; j++)
		{
			maze[i][j] = WALL;
		}
	}

	for (int i = 0; i < LEN; i++)
	{
		for (int j = 0; j < LEN; j++)
		{
			int p = i * LEN + j;
			if (i > 0)
			{
				Point pp;
				pp.x = p;
				pp.y = p - LEN;
				tem.push_back(pp);
			}
			if (j > 0)
			{
				Point pp;
				pp.x = p;
				pp.y = p - 1;
				tem.push_back(pp);
			}
		}
	}

	srand((unsigned)time(NULL));
	int n = rand() % 5;
	do
	{
		std::random_shuffle(tem.begin(), tem.end());
	} while (n--);

	initgraph(WID, WID);
	setorigin(LINELENGTH, LINELENGTH);
	LINESTYLE ls;
	getlinestyle(&ls);
	ls.thickness = LINELENGTH / 2;
	ls.style = ls.style | PS_ENDCAP_SQUARE;
	setlinestyle(&ls);
	for (int i = 0; i < LEN; i++)
	{
		for (int j = 0; j < LEN; j++)
		{
			putpixel(i * LINELENGTH, j * LINELENGTH, WHITE);
		}
	}

	for (int i = 0; i < tem.size(); i++)
	{
		int a = tem[i].x;
		int b = tem[i].y;
		if (g->connected(a, b))
		{
			tem[i].x = -1;
			tem[i].y = -1;
		}
		else
		{
			int ai = a / LEN;
			int aj = a % LEN;
			int bi = b / LEN;
			int bj = b % LEN;
			if (ai == bi)
			{
				int min = aj < bj ? aj : bj;
				int max = aj > bj ? aj : bj;
				min *= 2;
				max *= 2;
				for (int j = min; j <= max; j++)
				{
					maze[ai * 2][j] = 0;
				}
			}
			if (aj == bj)
			{
				int min = ai < bi ? ai : bi;
				int max = ai > bi ? ai : bi;
				min *= 2;
				max *= 2;
				for (int j = min; j <= max; j++)
				{
					maze[j][aj * 2] = 0;
				}
			}
		}
		Sleep(3);
	}

	ls.thickness = 5;
	setlinestyle(&ls);
	setlinecolor(RED);
	
	bool marked[MAZELEN][MAZELEN];
	memset(marked, false, sizeof(marked));
	Point start, end;
	start.x = MAZELEN - 1;
	start.y = 0;
	end.x = 0;
	end.y = 0;
	st.push(start);
	Point p;
	
	system("pause");

	while (true)
	{
		p = st.top();
		if (p.x == end.x && p.y == end.y)
		{
			break;
		}
		if ((p.x < MAZELEN - 1) && !marked[p.x + 1][p.y] && (maze[p.x + 1][p.y] == ROAD))
		{
			Point t;
			t.x = p.x + 1;
			t.y = p.y;
			marked[t.x][t.y] = 1;
			st.push(t);
			line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);
		}
		else if ((p.y < MAZELEN - 1) && !marked[p.x][p.y + 1] && (maze[p.x][p.y + 1] == ROAD))
		{
			Point t;
			t.x = p.x;
			t.y = p.y + 1;
			marked[t.x][t.y] = 1;
			st.push(t);
			line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);
		}
		else if ((p.x > 0) && !marked[p.x - 1][p.y] && (maze[p.x - 1][p.y] == ROAD))
		{
			Point t;
			t.x = p.x - 1;
			t.y = p.y;
			marked[t.x][t.y] = 1;
			st.push(t);
			line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);
		}
		else if ((p.y > 0) && !marked[p.x][p.y - 1] && (maze[p.x][p.y - 1] == ROAD))
		{
			Point t;
			t.x = p.x;
			t.y = p.y - 1;
			marked[t.x][t.y] = 1;
			st.push(t);
			line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);
		}
		else
		{
			Point t = st.top();
			st.pop();
			p = st.top();
			setlinecolor(WHITE);
			line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);
			setlinecolor(RED);
		}
		system("pause");
	}

	closegraph();
	system("pause");
	return 0;
}
```
运行结果自己跑着玩吧，反正我编译通过了。//逃