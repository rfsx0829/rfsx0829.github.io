<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一个图片迁移工具</title>
      <link href="/2019/720.html"/>
      <url>/2019/720.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个图片迁移工具"><a href="#一个图片迁移工具" class="headerlink" title="一个图片迁移工具"></a>一个图片迁移工具</h1><p>很久没写博客。可能是忘记了吧。</p><p>听到朋友问，为啥博客很多图片都看不到了，于是打开看看，确实出现了一些问题，原来用的简书的图床出了些问题，偶尔可以用偶尔又出问题，让人很是头疼。</p><p>于是我自己写了个图片迁移工具，把博客的 md 文件里，原来简书图床的图片批量下载，然后上传到自己的图床上或者是其他比较优秀的图床，比如语雀或者 GitHub 之类的，但是看了看语雀的 API 文档，目前的文件上传接口还没有完全开放，还需要自己去申请，考虑到 GitHub 或许在国内条件又不是很好，于是就决定上传到自己服务器上</p><p>正好也很久没写博客，现在做出了工具，正好可以写个博客来记录一下。</p><p>但其实很多详细的东西直接可以去看代码和 README 就可以了，在博客里我最多也就瞎扯扯。</p><p>工具具体呢，可以处理单 md 文件，也可以处理一个文件夹里所有的 .md 文件。</p><p>具体做的事情是</p><ol><li>找出所有的图片链接，用的是正则表达式，目前只检测 png 和 jpg 两类图片</li><li>从所有的链接中找出要替换的图床里的图片链接，因为不是所有的图片都是需要替换的，只有坏图床里的图片需要替换到好图床里，于是需要自己指定 专门挑出 哪个图床的链接。如果上传失败会将图片写入到本地。</li><li>挑出链接后，遍历，下载并重新上传，获得新的图片地址，暂时存在内存中</li><li>一个文件中所有符合条件的图片都下载并上传完成后，进行链接的文本替换</li><li>替换链接完成后，写入到 xxx_new.md 文件，原文件不影响</li></ol><p>基础功能很简单，但确实简化了我不少的工作。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Dio 网络问题一记</title>
      <link href="/2019/5290.html"/>
      <url>/2019/5290.html</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter-Dio-网络问题一记"><a href="#Flutter-Dio-网络问题一记" class="headerlink" title="Flutter Dio 网络问题一记"></a>Flutter Dio 网络问题一记</h1><h2 id="问题起因和描述"><a href="#问题起因和描述" class="headerlink" title="问题起因和描述"></a>问题起因和描述</h2><p>笔者无聊用 Flutter 写了个 APP 玩玩，在需要进行网络访问的时候，选择使用 <a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">Dio</a> 这个库</p><p>在 Debug 模式下表现一切正常，但是当我编译为发布版时，网络访问不能正常工作，错误为 Dio Error: OS Error: Permission Denied.</p><p><img src="./../pics/1559131545845-7b932922-efca-4015-b767-deceac464433.png" alt="Screenshot"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>读报错很容易知道，是权限问题，系统不允许进行网络访问</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然是系统不给权限，那就让系统给权限就好了</p><p>在 {project}/android/app/src/main/AndroidMainfest.xml 文件，在application标签前面加一行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>允许使用网络权限</p><p>添加之后，重新编译，问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dio </tag>
            
            <tag> 小问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些没有发布的项目</title>
      <link href="/2019/514.html"/>
      <url>/2019/514.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://styts.com/cycle-of-side-projects/" target="_blank" rel="noopener">原文链接(英文)</a></p><blockquote><p>作为一个程序员，我有100多个没有发布的个人项目。</p><p>它们通常是这样开始的：我对一个想法感到兴奋，估计可以在较短的时间内完成，比如一个周末或几周。结果也差不太多，我疯狂地工作一段时间，项目或多或少都写好了。</p><p>但是它能够发布了吗？它是否算完成了呢？有趣和令人兴奋的部分确实是基本完成了，能够证明某个概念是有效的。但是，又好像缺少了一些东西，不是特别能引起别人的兴趣，有一些乏味。项目缺乏设计或视觉呈现，这算不上很重要，功能才比较重要，项目确实能工作。</p><p>它也没有登陆页面和介绍页面，这些将对新用户非常友好。但我不是一个好的作家，写不出太多文字。我甚至讨厌写作，我害怕被别人评判，所以我选择不写。</p><p>最后一个缺失的部分是营销。世界上几乎没有任何事情，比一个内向的人想到一个创意更糟糕，因为他不得不向全世界推销自己的想法。如果世界批评你的项目怎么办？如果你了解到，别人已经做过了怎么办？世界也可能完全沉默不加理睬，就像以前的许多人一样，你的项目将沉没在互联网的深处。</p><p>这些缺失的部分不算多，可能还需要投入整个项目时间的20％。但是这最后的20％，对你来说，比80％用在编码的时间更难做到。因此，你可能会让项目就停在那里。何况世界上又出现了新的闪亮的东西，你又可以急切地在新东西上工作了。</p><p>再过一会，你就会去拥抱新项目，忘了旧项目。让那些没做完的事情继续保持没做完，让这样的周期变成永久化。</p></blockquote><p>说实话，看到这个，感同身受</p>]]></content>
      
      
      <categories>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当今世界计算机硬件与软件发展现状</title>
      <link href="/2019/513.html"/>
      <url>/2019/513.html</url>
      
        <content type="html"><![CDATA[<h1 id="当今世界计算机硬件与软件发展现状"><a href="#当今世界计算机硬件与软件发展现状" class="headerlink" title="当今世界计算机硬件与软件发展现状"></a>当今世界计算机硬件与软件发展现状</h1><h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><p>何为计算机？</p><p>计算机是一种根据一系列指令对数据进行处理的电子设备。</p><p>而不局限于我们经常接触到的个人电脑，个人电脑只是计算机的一种。</p><a id="more"></a><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><h3 id="回首历史"><a href="#回首历史" class="headerlink" title="回首历史"></a>回首历史</h3><h4 id="卡片机时代"><a href="#卡片机时代" class="headerlink" title="卡片机时代"></a>卡片机时代</h4><p>最初的阶段是卡片时期，即使用<strong>穿孔卡片</strong>作为指令的载体。</p><p>1801年雅卡尔发明的提花织布机，可以通过相互串联的穿孔卡片达到半自动生产，且更换卡片无需更改机械设计，是可编程化机器的里程碑。</p><h4 id="数字管时期"><a href="#数字管时期" class="headerlink" title="数字管时期"></a>数字管时期</h4><p>1930年时，四则运算已经成为了桌上型机械计算器的基本功能，但是动力全靠机械，效率极低。</p><p>第一部全电子化的桌上计算器是英国人研发的，以<strong>数字管</strong>和177个<strong>微型闸流管</strong>来显示数字。</p><h4 id="电子电路和图灵机"><a href="#电子电路和图灵机" class="headerlink" title="电子电路和图灵机"></a>电子电路和图灵机</h4><p>1930年代后期到1940年代，受到二次大战影响，此一时期被认为是计算机发展史中的混乱时期，战争开启了现代电脑的时代，电子电路，继电器，电容及真空管相继登场，取代机械器件，数字计算器开始得到广泛发展，使用包含继电器或真空管的电路，以打孔纸带作为输入和主要（非短期）储存媒介。</p><p>1936年，图灵发表的研究报告对计算机和计算机科学领域造成巨大冲击，这篇报告主要是为了证明循环处理程式的死角，亦即停机问题的存在。图灵也以算法概念为通用计算机（纯理论器件）作出定义，即图灵机。</p><p>1937年，美国数学家兼工程师 克劳德·香农 在麻省理工学院发表他的硕士论文，是史上首度将布尔代数应用在电子继电器和电闸上的人。论文题为《中继和交换电路的符号分析》（A Symbolic Analysis of Relay and Switching Circuits），是数字电路设计的实践基础。</p><p>同年，在贝尔实验室工作的乔治组装出了一部以继电器表示二进位制的电脑模型机。</p><h4 id="冯·诺伊曼结构"><a href="#冯·诺伊曼结构" class="headerlink" title="冯·诺伊曼结构"></a>冯·诺伊曼结构</h4><p>冯·诺伊曼写过一篇广为流传的文章《EDVAC独家报告》（First Draft of a Report on the EDVAC），内容描述EDVAC将程式和计算中的资料，设计储存在同一内存内。冯·诺伊曼的这项设计后来被称为<strong>冯·诺伊曼架构</strong>，成为发展第一部真正具有运作弹性、一般用途数字电脑的设计基础。</p><p>第一部成功运作的<strong>冯·诺伊曼结构</strong>电脑是1948年曼彻斯特大学的小规模实验机，又称“宝贝”。随后在1949年，曼彻斯特马克一号电脑登场，功能完整，以威廉管和<strong>磁鼓</strong>作为内存媒介，并且引进<strong>变址寄存器</strong>的功能。</p><p>1954年，IBM推出一款电脑体积较小，价格和善，后来广受欢迎。这款IBM 650重达900公斤，附属的电力供应器件也有1350公斤左右，两者各安置在与人等高的橱柜里。原本其<strong>磁鼓内存</strong>只能保存2000个十位数字组，还需要晦涩难明的编程程序才能有效运作，诸如此类的内存限制在之后的十年间主宰了编程程序，直到编程模组一番革命性的改变后，软件开发才有了较人性化的转变。</p><h3 id="CPU发展历程"><a href="#CPU发展历程" class="headerlink" title="CPU发展历程"></a>CPU发展历程</h3><p>从四位处理器，到六十四位酷睿微架构，这其中又经历了什么呢</p><h4 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h4><p><strong>摩尔定律</strong>是由英特尔（Intel）创始人之一戈登·摩尔提出的。其内容为：<strong>集成电路</strong>上可容纳的<strong>晶体管</strong>数目，约每隔两年便会增加一倍；经常被引用的“18个月”，是由英特尔首席执行官大卫·豪斯提出：预计18个月会将芯片的性能提高一倍。</p><p>摩尔定律是简单评估半导体技术进展的经验法则，其重要的意义在于大抵而言，若在相同面积的晶圆下生产同样规格的IC，随着制程技术的进步，每隔一年半，IC产出量就可增加一倍，换算为成本，即每隔一年半成本可降低五成，平均每年成本可降低三成多。就摩尔定律延伸，IC技术每隔一年半推进一个世代。</p><p>但是摩尔定律已经快要失效了。</p><p>为了让摩尔定律延续到更小的器件尺度，学术界和工业界在不同的材料、器件结构和工作原理方面的探索一直在进行中。探索的问题之一是晶体管的闸极设计。随着器件尺寸越来越小，能否有效的控制晶体管中的电流变得越来越重要。相比于三面都有闸极的<strong>多闸极晶体管</strong>，<strong>纳米线</strong>晶体管将闸极四面围住，从而进一步改善了闸极对电流的控制。</p><p>随着新工艺节点的不断推出，晶体管中原子的数量已经越来越少，种种物理极限制约着其进一步发展。比如当闸极长度足够短的时候，<strong>量子隧穿效应</strong>就会发生，会导致漏电流增加。关于摩尔定律的终点究竟还有多远，看法并不一致。有预测认为摩尔定律的极限将在2025年左右到来，但也有更乐观的预测认为还能持续更久。</p><h3 id="发展现状·集成芯片时期"><a href="#发展现状·集成芯片时期" class="headerlink" title="发展现状·集成芯片时期"></a>发展现状·集成芯片时期</h3><p>第三波电脑世代来临，电脑使用度爆炸性的成长，这些全仰赖杰克·基尔比和罗伯特·诺伊斯的独立发明集成电路，引领英特尔发明微处理器。在1960年代，大量的电脑技术和过去的第二波电脑世代重叠，直到1975年后期，第二波电脑世代的机器仍在持续量产。</p><p>微处理器的诞生连带刺激微电脑的发展，轻便小巧，物廉价美的电脑成为个人及小公司唾手可得的工具，微电脑在1970年代初登场，到了1980年代后就已经成为家家户户都可看到的产品了。电脑逐渐成为微电脑架构的天下，再加上来自大型电脑的特色后，现如今已主宰大部分的电脑市场。</p><h3 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h3><h4 id="量子计算机"><a href="#量子计算机" class="headerlink" title="量子计算机"></a>量子计算机</h4><p>量子计算机，字面意思，就是使用量子逻辑计算的设备。用来储存数据的对象是量子比特，使用量子算法进行数据操作。</p><p>紧接着1985年大卫·杜斯提出了量子图灵机模型。人们研究量子计算机最初很重要的一个出发点是探索通用计算机的计算极限。当使用计算机模拟量子现象时，因为庞大的希尔伯特空间而数据量也变得庞大。一个完好的模拟所需的运算时间则变得相当长，甚至是不切实际的天文数字。理查德·费曼当时就想到如果用量子系统所构成的计算机来模拟量子现象则运算时间可大幅度减少，从而量子计算机的概念诞生。半导体靠控制集成电路来记录及运算信息，量子计算机则希望控制原子或小分子的状态，记录和运算信息。</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="回首历史-1"><a href="#回首历史-1" class="headerlink" title="回首历史"></a>回首历史</h3><p>在计算机刚被发明创造的时候，还是非常笨重和昂贵的，所以能用上的都不是一般人，运行的软件也基本都是大公司的专有软件，如金融，军事，科研等方面，帮忙统计和计算各种数据之类的。</p><p>继续跟随发展，计算机最开始不是靠软件盈利，几乎全靠硬件，随着硬件生产规模越来越大，硬件降价，之后，软件业从计算机工业中独立出来，成为一枝新秀。那时，硬件厂商开放了他们的系统软件（由于没有这种开放，不能进一步推销他们的产品），有几个公司开始提供定制软件的服务，然而那时没有专门经销软件的公司。由于软件免费，用户相互赠送，使软件不断重用与推广，并鼓励共享软件的发展。例如，IBM科学用户组织SHARE提供了软件重用的目录清单，包含了三角函数分类和合并计算的多个数学程序，并对进入了SHARE目录中的软件产品，能给予此领域的最高荣誉。</p><p>再以后，甚至因为不够稳定而曾经出现过软件危机。软件方面投入的资金和人力无法控制，软件开发完成的时间无法确定，软件的可靠性等等。</p><p>稳定阶段中开始出现了计算机学科的学术讨论。第一个计算机科学程序在六十年代晚期奠基，不久以后又编制了第一个管理信息系统程序。当时计算机软件工程还没有从计算机学科中分离出来，直到微型计算机年代才独立成为一门学科。尽管当时没有形成学科，然而软件工程研究一直在进行，重点聚集在计算机语言的问题上。</p><p>在此阶段，一些计算机科学家大力宣传他们引入的新思想。人工智能就是第一个竭力宣扬的学科，即称之为“有知觉”的机器，可以模仿人类大脑的功能，并期望代替人类大脑去做任何事情。</p><h4 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h4><p>最初的计算机 都只能单机工作，还不能互相联系，直到互联网的问世。</p><p>在1950年代，通信研究者认识到需要允许在不同计算机用户和通信网络之间进行常规的通信。这促使了分散网络、排队论和分组交换的研究。1960年，美国国防部高等研究计划署（ARPA）出于冷战考虑创建的ARPA网引发了技术进步并使其成为互联网发展的中心。1973年，ARPA网扩展成互联网。</p><p>经过多年，互联网成功地容纳了原有的计算机网络中的大多数（尽管像FidoNet的一些网络仍然保持独立）。这一快速发展要归功于互联网没有中央控制，以及互联网协议非私有的特质，前者造成了互联网有机的生长，而后者则鼓励了厂家之间的兼容，并防止了某一个公司在互联网上称霸。</p><h3 id="发展现状"><a href="#发展现状" class="headerlink" title="发展现状"></a>发展现状</h3><h4 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h4><p>早期的人工智能研究人员直接模仿人类进行逐步的推理，就像是玩棋盘游戏或进行逻辑推理时人类的思考模式。到了1980和1990年代，利用<strong>概率</strong>和经济学上的概念，人工智能研究还发展了非常成功的方法处理<strong>不确定</strong>或不完整的资讯。</p><p>对于困难的问题，有可能需要大量的运算资源，也就是发生了“可能组合爆增”：当问题超过一定的规模时，计算机会需要天文数量级的存储器或是运算时间。寻找更有效的算法是优先的人工智能研究项目。</p><p>人类解决问题的模式通常是用最快捷、直观的判断，而不是有意识的、一步一步的推导，早期人工智能研究通常使用逐步推导的方式。人工智能研究已经于这种“次表征性的”解决问题方法获取进展：实体化Agent研究强调<strong>感知运动</strong>的重要性。神经网络研究试图以模拟人类和动物的大脑结构重现这种技能。</p><p>当前的人工智能只能算是初步发展，虽然已经影响到了我们生活的方方面面，但还是有很多可以做得更加好的地方，我近期还听到奋战在前线的优秀程序员说，众所周知人工智能靠人工，说明发展得还不够，还需快马加鞭。</p><h4 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h4><p>云计算是一种基于<strong>互联网</strong>的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备。</p><p>云计算是继1980年代大型计算机到客户端-服务器的大转变之后的又一种巨变。用户不再需要了解“云”中基础设施的细节，不必具有相应的专业知识，也无需直接进行控制。云计算描述了一种基于互联网的新的IT服务增加、使用和交付模式，通常涉及通过互联网来提供动态<strong>易扩展</strong>而且经常是<strong>虚拟化</strong>的资源。</p><p>云计算已经融入我们的生活了，很多东西都离不开云，即使有些人还不太了解。</p><p>云教育，云物联，等等，都与我们的息息相关，说个再贴近一点的，经常听到的阿里云腾讯云之类对外提供云服务的，前段时间还有同学找我帮助他申请域名和服务器的操作。</p><p>但当前的云计算的发展程度也还不够高，虽然同人工智能一样已经对人们的生活有了很大的提升，但他们的潜力远不止于此。</p><h3 id="从编程方面来讲"><a href="#从编程方面来讲" class="headerlink" title="从编程方面来讲"></a>从编程方面来讲</h3><h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><p>或者也叫面向函数，在我最开始学习的时候，并不了解面向对象的代码架构设计和代码编程实现。所以要从字面上来区分函数和函数之间的关系，主要就靠函数命名、放在同一个代码文件里、放在同一个代码目录文件夹里来区分他们之间的关联性。</p><p>在函数时代，也没啥异常保护、异常处理、异常日志的函数编写基本原则，所以我们除了命名以外，主要注重的就是函数的输入数据参数以及格式、输出数据的参数以及格式。</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>因为有了类这个东西，所以函数就可以物以类聚了。有的函数属于私有函数只能这个类里面才能调用，有的函数属于公有函数可以供外部调用。</p><p>我们平时使用类还很初级，往往是一个源代码文件中就定义一个类。而且类也没有使用继承，也就是说我所有的类都是平行的，类和类之间通过Public型的公开函数调用才产生了关系。</p><h4 id="面向接口"><a href="#面向接口" class="headerlink" title="面向接口"></a>面向接口</h4><p>何为面向接口？可能有很多人学了多年编程都没搞懂。</p><p>在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类。</p><p>这样做的好处是显而易见的，首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉，就像我们将一个金士顿16G硬盘换成一个闪迪的128G的硬盘，计算机其他地方不用做任何改动，而是把原硬盘拔下来、新硬盘插上就行了，因为计算机其他部分不依赖具体硬盘，而只依赖一个IDE接口，只要硬盘实现了这个接口，就可以替换上去。从这里看，程序中的接口和现实中的接口极为相似，所以我一直认为，接口（interface）这个词用的真是神似！</p><h4 id="面向组件"><a href="#面向组件" class="headerlink" title="面向组件"></a>面向组件</h4><p>写C/S/S三层架构，业务逻辑层独立出来，而且是物理独立部署，这样客户端代码和业务逻辑层代码就必须要彻底分开，不能不清不楚地混杂在一起了。大量使用精心的接口设计、对象设计。</p><p>因为有了独立的业务逻辑层，那么这些代码（接口/类）何时创建对象实例，何时释放，这些对象实例要运行在哪个进程容器中，就有了要求了。因而就产生了组件容器和组件。组件容器来管理组件的全生命周期（安全、创建、并发访问控制、休眠、激活唤醒、计数、摧毁释放内存），组件管理器就来管理组件的注册、发现等。</p><p>正如《COM本质论》的作者Don Box说.NET就是更好的COM，对啊，微软的意思是，以后所有的应用都应该运行在组件容器中，不管是单机应用，还是C/S应用，还是C/S/S应用，每个应用都要运行在组件容器中，由组件容器来屏蔽和管理内存的创建与回收，不要把内存的创建与释放直接袒露给开发者，否则开发者技术能力水平不一，有的烂的程序员管理不好内存，很容易就会使应用占满内存并导致操作系统崩溃。</p><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p><strong>微服务</strong>是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API 集相互通信。</p><p>随着发展，以前那一套很棒，很理想：一整套J2EE体系，WebService + EJB完美组件模型  +组件容器/管理器中间件，包括技术架构师。是多么多么大的市场啊。</p><p>但程序员是实用主义者，怎么简单怎么来。随着第二波互联网创业热崛起，大干快上才是王道，没钱用开源开干才是王道。且正值Google崛起如日中天，Google统一开放了自己的Open API，非常轻量。这已经是微服务流行的启动了。但这时候还不能称作微服务，可以称作简化服务。再加之大众需求趋势及亚马逊的推波助澜，终于到了微服务的大盛时期。</p><h3 id="展望未来-1"><a href="#展望未来-1" class="headerlink" title="展望未来"></a>展望未来</h3><h4 id="高度人工智能"><a href="#高度人工智能" class="headerlink" title="高度人工智能"></a>高度人工智能</h4><p>前面讲了当前的人工智能发展，未来也是离不开人工智能的，在许多科幻电影中，人工智能几乎必不可少。人们也都憧憬着人工智能的发展。</p><p>经过60多年的发展，人工智能在算法、算力（计算能力）和算料（数据）等“三算”方面取得了重要突破，正处于从“不能用”到“可以用”的技术拐点，但是距离“很好用”还有诸多瓶颈。那么在可以预见的未来，人工智能发展将会出现怎样的趋势与特征呢？</p><p><strong>从专用智能向通用智能发展。</strong>如何实现从专用人工智能向通用人工智能的跨越式发展，既是下一代人工智能发展的必然趋势，也是研究与应用领域的重大挑战。2016年10月，美国国家科学技术委员会发布《国家人工智能研究与发展战略计划》，提出在美国的人工智能中长期发展策略中要着重研究通用人工智能。阿尔法狗系统开发团队创始人戴密斯·哈萨比斯提出朝着“创造解决世界上一切问题的通用人工智能”这一目标前进。微软在2017年成立了通用人工智能实验室，众多感知、学习、推理、自然语言理解等方面的科学家参与其中。</p><p><strong>从人工智能向人机混合智能发展。</strong>借鉴脑科学和认知科学的研究成果是人工智能的一个重要研究方向。人机混合智能旨在将人的作用或认知模型引入到人工智能系统中，提升人工智能系统的性能，使人工智能成为人类智能的自然延伸和拓展，通过人机协同更加高效地解决复杂问题。在我国新一代人工智能规划和美国脑计划中，人机混合智能都是重要的研发方向。</p><p><strong>从“人工+智能”向自主智能系统发展。</strong>当前人工智能领域的大量研究集中在深度学习，但是深度学习的局限是需要大量人工干预，比如人工设计深度神经网络模型、人工设定应用场景、人工采集和标注大量训练数据、用户需要人工适配智能系统等，非常费时费力。因此，科研人员开始关注减少人工干预的自主智能方法，提高机器智能对环境的自主学习能力。例如阿尔法狗系统的后续版本阿尔法元从零开始，通过自我对弈强化学习实现围棋、国际象棋、日本将棋的“通用棋类人工智能”。在人工智能系统的自动化设计方面，2017年谷歌提出的自动化学习系统（AutoML）试图通过自动创建机器学习系统降低人员成本。</p><p><strong>人工智能将加速与其他学科领域交叉渗透。</strong>人工智能本身是一门综合性的前沿学科和高度交叉的复合型学科，研究范畴广泛而又异常复杂，其发展需要与计算机科学、数学、认知科学、神经科学和社会科学等学科深度融合。随着超分辨率光学成像、光遗传学调控、透明脑、体细胞克隆等技术的突破，脑与认知科学的发展开启了新时代，能够大规模、更精细解析智力的神经环路基础和机制，人工智能将进入生物启发的智能阶段，依赖于生物学、脑科学、生命科学和心理学等学科的发现，将机理变为可计算的模型，同时人工智能也会促进脑科学、认知科学、生命科学甚至化学、物理、天文学等传统科学的发展。</p><p><strong>人工智能产业将蓬勃发展。</strong>随着人工智能技术的进一步成熟以及政府和产业界投入的日益增长，人工智能应用的云端化将不断加速，全球人工智能产业规模在未来10年将进入高速增长期。例如，2016年9月，咨询公司埃森哲发布报告指出，人工智能技术的应用将为经济发展注入新动力，可在现有基础上将劳动生产率提高40%；到2035年，美、日、英、德、法等12个发达国家的年均经济增长率可以翻一番。2018年麦肯锡公司的研究报告预测，到2030年，约70%的公司将采用至少一种形式的人工智能，人工智能新增经济规模将达到13万亿美元。</p><h4 id="云计算时代"><a href="#云计算时代" class="headerlink" title="云计算时代"></a>云计算时代</h4><p>云计算还仅仅只是一个开始，相信再多些时日，必然是一个新的时代。或者说，其实现在已经是云时代的初期了。</p><p>所有的计算都在云上完成，只要有网络，就可以做成任何事情，云可以为任何终端提供几乎无穷的算力，和几乎无限的储存。再加上以后网络的高度普及，和高速通信的发展，云时代给人们生活带来的便利难以想象。</p><h4 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h4><p>去中心化方面，现在比较成熟的技术非区块链莫属了，这是我最看好的技术之一，近两年很多人说区块链凉了，那群人是真的不懂技术，比特币是区块链的一个产物而已，比特币凉了跟区块链有什么关系，区块链技术永远不凉，去中心化是大势所趋，即使现在没有被人们所注意，在多年后，许多许多年后，必然是去中心化的天下。</p><p>集权永远不可取，民主第一！我相信任何热爱自由民主科学的人，都会热爱去中心化的技术！而这，才是未来！</p>]]></content>
      
      
      <categories>
          
          <category> Papers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
            <tag> Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gopher China 2019 总结</title>
      <link href="/2019/4301.html"/>
      <url>/2019/4301.html</url>
      
        <content type="html"><![CDATA[<h1 id="Gopher-China-2019-总结"><a href="#Gopher-China-2019-总结" class="headerlink" title="Gopher China 2019 总结"></a>Gopher China 2019 总结</h1><h2 id="会前"><a href="#会前" class="headerlink" title="会前"></a>会前</h2><p>早早就报了名，真正开始，也依然避免不了心有悸动</p><p>从学校出发去北京，在北京租了一间屋子，五个人住，屋子还挺前卫</p><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>虽然我们都早起，但是因为北京的早高峰，我们挤地铁还是花费了很多时间，到达目的地时大会已经快开始，只得草草签到并去一些展台看了看，简单领了些小礼物</p><a id="more"></a><h3 id="大型微服务框架设计"><a href="#大型微服务框架设计" class="headerlink" title="大型微服务框架设计"></a>大型微服务框架设计</h3><p>第一场就这么强力，直接大谈设计，不得不说，我听懂的部分不算多</p><p>涉及了很多 大型框架 所需要注意的问题和解决思路，为需要自己开发大型框架的团队或公司提供了非常宝贵的建议，但因为我个人并不需要开发大型的微服务框架，所以也不是很感冒，但依然学到了很多。</p><h3 id="Grab-路径规划引擎-和-ETA"><a href="#Grab-路径规划引擎-和-ETA" class="headerlink" title="Grab 路径规划引擎 和 ETA"></a>Grab 路径规划引擎 和 ETA</h3><p>Grab 是一个主要服务于东南亚的打车公司，不得不说，这一个我很有印象，因为他们确实很强，但其实主要的内容都是算法，从所讲的 毛细地图补全，定位修复 到 路径规划 到 ETA(Estimated Time of Arrival)，无一不是跟算法息息相关，以及智能动态寻路和路径偏好选择，全是算法。跟 Go 的关系呢，就在于用 Go 实现这些功能的话，效率比较高，而且可以微服务化，高度并发</p><h3 id="TiDB"><a href="#TiDB" class="headerlink" title="TiDB"></a>TiDB</h3><p>TiDB 在之前我仅仅只是听过这个数据库，一直没有详细地去了解和体验。听过讲解之后觉得其实还挺不错。</p><p>他们所讲的内容挺丰富的，不仅有数据处理相关的内容，比如怎么提高 Query 效率，怎么高效储存等。还有一个新的小工具，FailPoint，应该是 gofail 的改良，看起来挺厉害的，值得一试</p><h3 id="Testing-how-what-why"><a href="#Testing-how-what-why" class="headerlink" title="Testing; how, what, why"></a>Testing; how, what, why</h3><p>这一场真的是非常厉害，是一位 Go 源码开发者所分享，我没资格评价，但强推，自行看 PPT</p><h3 id="Context-amp-Error"><a href="#Context-amp-Error" class="headerlink" title="Context &amp; Error"></a>Context &amp; Error</h3><p>这场很好理解，其实就讲了在业务开发中 Context 和 Error 应该怎么处理比较合理，挺不错的</p><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>这场也是大佬讲的，主要是讲解同步的方法和原理，各种锁，非常详细！个人强烈推荐深入研究</p><p><a href="https://colobu.com/" target="_blank" rel="noopener">大佬的博客</a> 也是藏宝地，值得探索</p><h3 id="百度-APP"><a href="#百度-APP" class="headerlink" title="百度 APP"></a>百度 APP</h3><p>这个，跟前面几个相比，就显得很不充实了，没多少干货，但 PPT 还是可以一看吧</p><h3 id="Real-Time-SaaS"><a href="#Real-Time-SaaS" class="headerlink" title="Real-Time SaaS"></a>Real-Time SaaS</h3><p>这是一个做在线教育的公司的开发者来讲的，主要涉及的技术就是 WebRTC， 其他都没啥</p><h2 id="晚宴"><a href="#晚宴" class="headerlink" title="晚宴"></a>晚宴</h2><p>不得不说，我们团队太强了，一共一百个名额的晚宴，我们五个人居然都成功拿到入场资格。。</p><p>总觉得晚宴才是整个大会的精华部分，不仅晚餐精致丰富不限量。而且还有各种大佬分享各方面的坑和经验。而且都是如此近距离的观察和聆听嗷，很多公司很多大佬居然就坐在旁边桌吃饭，这是怎样一种体验，以我的话来说，就是我这辈子没这么酷过</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>有了第一天的经验，第二天就不是那么拘谨了，轻车熟路的到达会场，开始听又一批大佬讲座</p><h3 id="MinIO-对象储存"><a href="#MinIO-对象储存" class="headerlink" title="MinIO 对象储存"></a>MinIO 对象储存</h3><p>总体就是讲 MinIO 的各种优势，推荐使用</p><h2 id="干货PPT"><a href="#干货PPT" class="headerlink" title="干货PPT"></a>干货PPT</h2><p><a href="https://www.yuque.com/techcats/imxk6x" target="_blank" rel="noopener">查看PPT列表</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小结 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书句子收集</title>
      <link href="/2019/4211.html"/>
      <url>/2019/4211.html</url>
      
        <content type="html"><![CDATA[<h1 id="觉得好的句子，就收集在这里吧"><a href="#觉得好的句子，就收集在这里吧" class="headerlink" title="觉得好的句子，就收集在这里吧"></a>觉得好的句子，就收集在这里吧</h1><p>虽然自己在每天的日记里也会记录一些句子，这里就不把那些搬运过来，日记里记录短句，这里记录长句吧</p><a id="more"></a><h3 id="《共产党宣言》"><a href="#《共产党宣言》" class="headerlink" title="《共产党宣言》"></a>《共产党宣言》</h3><blockquote><ol><li>现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增值资本的时候才能找到工作</li><li>由于推广机器和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单，极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。</li><li>现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就像士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅仅是资产阶级的，资产阶级国家的奴隶，他们每日每时都受机器，受监工，首先是受各个经营工厂的资产者本人的奴隶。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙，可恨和可恶。</li><li>手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。</li></ol></blockquote><h3 id="《毛泽东选集》卷一"><a href="#《毛泽东选集》卷一" class="headerlink" title="《毛泽东选集》卷一"></a>《毛泽东选集》卷一</h3><blockquote><ol><li>他们觉得现在如果只使用和从前相等的劳动，就会不能维持生活。必须增加劳动时间，每天起早散晚，对于职业加倍注意，方能维持生活。</li><li>这派议论貌似有理，其实也是错的。第一，上述那些事，都是土豪劣绅，不法地主自己逼出来的。土豪劣绅，不法地主，历来凭借实力称霸，践踏农民，农民才有这种很大的反抗。凡是反抗最力，乱子闹得最大的地方，都是土豪劣绅，不法地主为恶最甚的地方。农民的眼睛，全然没有错的。谁个劣，谁个不劣，谁个最甚，谁个稍次，谁个惩办要严，谁个处罚从轻，农民都有极明白的计算，罚不当罪的极少。第二，革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动。</li><li>矫枉必须过正，不过正不能矫枉。</li><li>以前土豪劣绅的残忍，土豪劣绅造成的农村白色恐怖是这样，现在农民起来枪毙几个土豪劣绅，造成一点小小的镇压反革命派的恐怖现象，有什么理由说不应该？</li><li>封建时代独裁专断的恶习惯深中于群众乃至党员的头脑中，一时扫除不净，遇事贪图便利，不喜欢麻烦的民主制度。</li><li>本位主义，一切只知道为四军打算，不知道武装地方群众是红军的重要任务之一。这是一种放大了的小团体主义。</li><li>有少数同志囿于四军的局部环境，以为除此就没有别的革命势力了。因此，保存实力，避免斗争的思想非常浓厚。这是机会主义的残余。</li><li>不顾主客观条件，犯着革命的急性病，不愿意艰苦地做细小严密的群众工作，只想大干，充满着幻想。这是盲动主义的残余。</li></ol></blockquote><h3 id="《在路上》"><a href="#《在路上》" class="headerlink" title="《在路上》"></a>《在路上》</h3><p>本来这本里也是有很多好句子的，但几乎都是短句，就不记录了</p>]]></content>
      
      
      <categories>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collections </tag>
            
            <tag> Reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现简单Shell</title>
      <link href="/2019/409.html"/>
      <url>/2019/409.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-语言实现简单-Shell"><a href="#C-语言实现简单-Shell" class="headerlink" title="C 语言实现简单 Shell"></a>C 语言实现简单 Shell</h1><p>直接上代码</p><a id="more"></a><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>  buf[MAXLINE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Fork Error !\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Wait Error !\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的原理很简单，循环从标准输入读取命令，读取到之后调用系统函数 execlp 执行命令。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>但是这样其实只能实现无参数调用，如果加参数就会产生错误，像这样</p><p><img src="./../pics/1554896522521-bd50a48e-0eef-43ad-9cb2-4a7d9f3744e2.png" alt="image.png"></p><p>那么想办法来改进一下</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>注意到 其实在调用 exec 系列函数是可以传数组参数的，其中有一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span><span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * __file, <span class="keyword">char</span> * <span class="keyword">const</span> * __argv)</span></span>;</span><br></pre></td></tr></table></figure><p>于是，这样来改进程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>  buf[MAXLINE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        <span class="keyword">char</span>* argv[<span class="number">10</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> args = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buf[len - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将读取到的字符串，解析成参数的数组保存在 argv 中，再传给 execlp</span></span><br><span class="line">        argv[args] = (<span class="keyword">char</span>*)buf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">' '</span> &amp;&amp; buf[i+<span class="number">1</span>] != <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buf[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(buf[i+<span class="number">1</span>] != <span class="string">' '</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    argv[++args] = (<span class="keyword">char</span>*)(buf + i+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// fork 函数 一次调用两次返回，对父进程返回子进程的 pid ，对子进程返回 0，如果返回值小于 0 则表示有错误</span></span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Fork Error !\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            execvp(argv[<span class="number">0</span>], argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Wait Error !\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再演示"><a href="#再演示" class="headerlink" title="再演示"></a>再演示</h2><p>看看改进后的效果，是否可以支持加参数了</p><p><img src="./../pics/1554900459904-1e5d6fa6-5ef1-4357-a386-fa1920853ee4.png" alt="image.png"></p><p>就可以支持参数了，很好嗷</p>]]></content>
      
      
      <categories>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 问题一记</title>
      <link href="/2019/406.html"/>
      <url>/2019/406.html</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter-环境配置的小问题"><a href="#Flutter-环境配置的小问题" class="headerlink" title="Flutter 环境配置的小问题"></a>Flutter 环境配置的小问题</h1><p>因为之前重置过 Mac 一次，导致我的 Flutter 开发环境没有了，又得重新配置环境，而这个过程，真的是让我很头大，我觉得这甚至可以写进博客，这里可以稍微记录下大体的思路</p><h2 id="下载-Flutter-并添加-bin-到-PATH"><a href="#下载-Flutter-并添加-bin-到-PATH" class="headerlink" title="下载 Flutter 并添加 bin 到 PATH"></a>下载 Flutter 并添加 bin 到 PATH</h2><p>这一步倒是没什么问题，轻车熟路的，一下子就搞定了</p><h2 id="配置-Android-SDK"><a href="#配置-Android-SDK" class="headerlink" title="配置 Android SDK"></a>配置 Android SDK</h2><p>这是最烦的，在这里耗费了不知道多少时间和好心情</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>第一个问题，下载，本来没什么难度，但是。。。</p><a id="more"></a><p>在 Flutter 的官方文档上有这么一个 Note</p><p><img src="./../pics/1554481707317-e938bb0a-666c-48fb-970e-eb7592538ce5.png" alt="Note"></p><p>翻译一下：Flutter <strong>依赖一个 Android Studio 的完整安装</strong> 来支持它对 Android 平台的依赖，然而，你可以在很多编辑器里写你的 Flutter 应用</p><p>官网说需要一个完整的安装。。但我记得之前好像没有装 Android Studio 也能用啊，这次怎么回事</p><p>那。。到底是下载完整的 Android Studio 呢还是只下载 Command Line Tool 呢</p><p>我选择了后者</p><h3 id="Flutter-doctor"><a href="#Flutter-doctor" class="headerlink" title="Flutter doctor"></a>Flutter doctor</h3><p>Flutter 不认 Android SDK，始终说缺一个 platforms 文件夹，才知道原来这是可以通过 sdkmanager 安装的，于是 执行 sdkmanager 试试，得到了报错。。。网上一查。。。是Java的问题</p><h3 id="Java-版本冲突"><a href="#Java-版本冲突" class="headerlink" title="Java 版本冲突"></a>Java 版本冲突</h3><p>网上查了很久才知道，原来 sdkmanager 只支持 JDK 10 及以下的，但是我之前。。。刚装了 JDK 12。。</p><p>于是，卸载，装 JDK 8</p><p>ps： 为什么是 JDK 8 不是 JDK 10 ？</p><p>ps： 因为 JDK8 可以直接支持 sdkmanager，9 和 10 还要去加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_OPTS=<span class="string">'-XX:+IgnoreUnrecognizedVMOptions --add-modules java.se.ee'</span></span><br></pre></td></tr></table></figure><h3 id="Java-解决方案"><a href="#Java-解决方案" class="headerlink" title="Java 解决方案"></a>Java 解决方案</h3><ol><li>JDK 8 及以下，可直接使用 sdkmanager 安装 Android SDK</li><li>JDK 9 和 JDK 10，需添加环境变量让 sdkmanager 能找到那个模块，然后再正常使用</li><li>JDK 11 和 JDK 12，添加环境变量无作用，因为。。那个包被移除了。。只能装低版本。。。</li></ol><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>最后的，其实挺简单，通过 sdkmanager 安装好 platforms 和 build-tools 之后，添加一个 ANDROID_HOME  就完事了，再执行 flutter doctor 看看，应该就可以识别 SDK 了</p><p>ps：可能还会有证书问题，这个 flutter 给了提示，按提示来可以手动确认证书</p><h2 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h2><p>电脑环境倒是配置好了，手机又出问题了，之前在玩 Island，但似乎它的权限有点过大了，居然把 Android 调试给劫持了，把这个软件里面的一个功能关掉才能正常连接电脑。。。</p><p>然后几分钟后，手机疯狂死机重启。。。</p><p>然后就重装了 Pixel Experience CAF</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>深夜了，环境终于全部搞完，我的三天假期就只剩下两天来做开发，一天都被配这个环境给浪费掉了，从心说一句，垃圾 Java ！自己都不向下兼容，你开发**呢</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小问题 </tag>
            
            <tag> Flutter </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探 Kubernetes（二）</title>
      <link href="/2019/3311.html"/>
      <url>/2019/3311.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录一些小问题"><a href="#记录一些小问题" class="headerlink" title="记录一些小问题"></a>记录一些小问题</h1><h2 id="VirtualBox-出现-NS-ERROR-FAILURE-0x80004005-错误"><a href="#VirtualBox-出现-NS-ERROR-FAILURE-0x80004005-错误" class="headerlink" title="VirtualBox 出现 NS_ERROR_FAILURE(0x80004005) 错误"></a>VirtualBox 出现 NS_ERROR_FAILURE(0x80004005) 错误</h2><p>这个问题我是很懵逼的，一开始不知道为什么出现的，经过许多查阅后，得到了几个解法（但是对我的问题没用，似乎这个错误的产生原因有许多）</p><ol><li>重装 VirtualBox</li><li>VirtualBox 文件夹里 改把 vbox 文件删了，重开虚拟机</li><li>卸载重装后，在 设置-隐私和安全 中允许给 VirtualBox 权限</li></ol><p>如果这几个方法解决不了你的问题，那还是自己Google吧</p><p>ps: 我的问题就很厉害了，同样是这个报错，但是百般搜索无果，可能是我动坏了底层的东西，重装系统之后问题解决</p><h2 id="Minukube-启动时-Pull-Image-失败"><a href="#Minukube-启动时-Pull-Image-失败" class="headerlink" title="Minukube 启动时 Pull Image 失败"></a>Minukube 启动时 Pull Image 失败</h2><p>这个问题。。主要还是因为 Kubernetes 是外国的嘛，国内访问的话延迟会比较高或者被 Block，所以解决方案也很简单</p><a id="more"></a><ol><li>代理</li><li>用国内可以访问的源</li></ol><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理的话，就不用多解释了，一般配置好之后会监听在某个端口上，我们要做的就是让 Minikube 在 Pull Image 的时候走这个端口，直接在终端配置环境变量就行了</p><blockquote><p>export HTTP_PROXY=127.0.0.1:8080<br>export HTTPS_PROXY=127.0.0.1:8080</p></blockquote><p>或者</p><blockquote><p>HTTP_PROXY=127.0.0.1:8080 HTTPS_PROXY=127.0.0.1:8080 minikube start</p></blockquote><h3 id="能访问的源"><a href="#能访问的源" class="headerlink" title="能访问的源"></a>能访问的源</h3><p>这个就比较简单了，DockerHub，就行，虽然还是比较慢，很多 Kubernetes 的镜像在 DockerHub 都有嗷，只要Pull下来改一下 tag 就行了</p><blockquote><p>docker pull mirrorgooglecontainers/kube-apiserver:v1.14.0<br>docker tag mirrorgooglecontainers/kube-apiserver:v1.14.0 k8s.gcr.io/kube-apiserver:1.14.0</p></blockquote><h2 id="Kubernetes-使用-Docker-本地的-Image"><a href="#Kubernetes-使用-Docker-本地的-Image" class="headerlink" title="Kubernetes 使用 Docker 本地的 Image"></a>Kubernetes 使用 Docker 本地的 Image</h2><p>上一篇文章中我提到了一个，没有解释的神奇命令，这里来解释一下</p><p>先说问题和解决方案，再详细描述</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题就是 不知道本地有一个Docker，Minikube 里面还有另外一个 Docker，并不互通</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在执行 <code>docker build</code> 之前，先执行一句 <code>eval $(minikube docker-env)</code> 使 Docker client 连接到 Minikube 中的 Docker daemon 上，之后的操作就可以正常进行了</p><h3 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h3><p>自己写了一个简单的 HelloWorld 服务，打算用 Kubernetes 部署，看到书上讲 Kubernetes 是可以直接使用Docker 镜像的，于是将服务构建成镜像，但没有推送到 Hub 上，打算就在本地供测试使用，万万没想到，出现了一些问题</p><h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><p>构建镜像之后，执行 <code>docker images</code> 能看到镜像构建成功</p><p><img src="./../pics/1554035962870-74984556-e663-4c6f-bb3e-c5a2a0fde779.png" alt="docker images"></p><p>但是在创建 Deployments 后启动 Pod 的时候出现了问题</p><blockquote><p>$ kubectl run hello-go –image=hello-go:v1.0 –port=8080<br>deployment.apps “hello-go” created<br>$ kubectl get pods</p></blockquote><p><img src="./../pics/1554192581403-b6458b9b-69c1-4813-87f3-d177dc0b8816.png" alt="kubectl get pods"></p><p>结果又出现了错误，实在搞不懂为什么明明本地有镜像 Minikube 却还要去拉取，禁用拉取之后又告诉不行，死活不使用本地的镜像，于是又开始查询，经过了很长时间的查询（可能书上有但我不仔细），才找到了解决方案和原因，<strong>原来 Minikube 自己维护了一个 Docker daemon，可以通过 <code>minikube ssh</code> 命令连接到 Minikube 的 shell ，再执行 <code>docker images</code> 查看 Minikube 内的 Docker 镜像</strong></p><blockquote><p>$ minikube ssh<br>$ docker images</p></blockquote><p><img src="./../pics/1554194007240-2217cf6d-f9dd-44db-beed-b042d183cf7c.png" alt="docker images"></p><p>可以看到，<strong>原来 Minikube 的本地真的没有 hello-go 镜像，这就很好的解释了为什么它会去拉取镜像，设置为永不拉取之后出现错误的问题了</strong></p><p>知道问题因何而起，那解决起来就简单了</p><p>注意到 Minikube 有一个子命令 docker-env</p><p><img src="./../pics/1554194287519-8c95d777-7d86-4934-a49c-88b711e2f30f.png" alt="minikube"></p><p>执行看看</p><p><img src="./../pics/1554194319879-5a4fbbac-1b3d-497f-92ab-f1708f364b98.png" alt="minikube docker-env"></p><p>给出了 Minikube 内部 Docker daemon 的地址和端口，提示执行 <code>eval $(minikube docker-env)</code> ，照着做就可以使你的 Docker client 直接操作 Minikube 中的 Docker daemon，于是再构建镜像就是保存在 Minikube 中了</p><blockquote><p>$ eval $(minikube docker-env)<br>$ cd ./projectDirectory     // 将工作目录切换到项目文件夹下<br>$ docker build -t hello-go:v1.0 .<br>$ docker images</p></blockquote><p><img src="./../pics/1554194695441-a57f6a9d-0830-4820-875c-857511f19727.png" alt="docker images"></p><p>这样，就成功构建了镜像并且镜像是保存在 Minikube 中的 Docker 中了，再用 kubectl 创建 deployments</p><blockquote><p>$ kubectl run hello-nice –image=hello-go:v1.0 –port=8080<br>deployment.apps “hello-nice” created<br>$ kubectl get pods</p></blockquote><p><img src="./../pics/1554194859859-fd9c492f-d9d5-4d01-bb4a-3c8326bbb2c0.png#align=left&amp;display=inline&amp;height=137&amp;name=image.png&amp;originHeight=137&amp;originWidth=675&amp;size=27688&amp;status=done&amp;width=675" alt="kubectl get pods"></p><p>可以看到，不仅新建的 Pods 正常运行了，而且之前因为没有镜像而出错的 Pods 都正常了！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在尝试minikube的过程中笔者就只遇到了这些问题，很庆幸都解决掉了，那这篇文章就记录到这里。</p><p>读者在Minikube使用过程中有什么问题都可以联系笔者噢，说不定可以帮点小忙:)</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小问题 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探 Kubernetes（一）</title>
      <link href="/2019/3310.html"/>
      <url>/2019/3310.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录初探-Kubernetes-的过程"><a href="#记录初探-Kubernetes-的过程" class="headerlink" title="记录初探 Kubernetes 的过程"></a>记录初探 Kubernetes 的过程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一直有想学习 Kubernetes ，最近看了些书，也自己用了用，也遇到了一些小问题，值得写篇博客记录一下</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于笔者仅是自学如何使用 Kubernetes，仅是单机版，还未到部署到生产环境的时候，且使用的是 Mac 电脑，故选择使用 Minikube</p><p>要安装使用 Minikube ，需要先安装 VirtualBox ，以下是一些过程</p><a id="more"></a><h3 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h3><p><a href="https://www.virtualbox.org" target="_blank" rel="noopener">VirtualBox官网</a> 提供了下载，或者可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/virtualbox/" target="_blank" rel="noopener">清华大学开源软件镜像站</a> 下载</p><p>下载完成之后，打开安装包安装即可</p><h3 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h3><p><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">Minikube</a> 是 Minikube 在 Github 中的项目地址，可以在 Release 标签中找到最新版本下载</p><blockquote><p>$ cd ~/Downloads<br>$ chmod +x ./minikube<br>$ mv ./minikube /usr/local/bin/minikube</p></blockquote><p>这里是给下载的 minikube 加上执行权限后放到 /usr/local/bin 里面，也可以自己选择放在任意 PATH 里</p><p>然后运行测试一下是否安装完成</p><blockquote><p>$ minikube version<br>minikube version: v1.0.0</p></blockquote><p>正确显示出 minikube 的版本，安装成功！</p><h3 id="Kubectl"><a href="#Kubectl" class="headerlink" title="Kubectl"></a>Kubectl</h3><p>Kubectl 是用于控制 Kubernetes 的，可通过包管理程序安装(Mac 用 brew ，Centos 用 yum，Ubuntu 用 apt)</p><blockquote><p>$ brew install kubernetes-cli<br>$ kubectl<br>kubectl controls the Kubernetes cluster manager.</p><p>Find more information at: <a href="https://kubernetes.io/docs/reference/kubectl/overview/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/kubectl/overview/</a><br>…</p></blockquote><p>安装成功，接下来可以准备启动了</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><blockquote><p>$ minikube start<br>😄  minikube v1.0.0 on darwin (amd64)<br>🤹  Downloading Kubernetes v1.14.0 images in the background …<br>💡  Tip: Use ‘minikube start -p <name>‘ to create a new cluster, or ‘minikube delete’ to delete this one.<br>🏃  Re-using the currently running virtualbox VM for “minikube” …<br>⌛  Waiting for SSH access …<br>📶  “minikube” IP address is 192.168.99.104<br>🐳  Configuring Docker as the container runtime …<br>🐳  Version of container runtime is 18.06.2-ce<br>⌛  Waiting for image downloads to complete …<br>✨  Preparing Kubernetes environment …<br>🚜  Pulling images required by Kubernetes v1.14.0 …<br>🔄  Relaunching Kubernetes v1.14.0 using kubeadm …<br>⌛  Waiting for pods: apiserver proxy etcd scheduler controller dns<br>📯  Updating kube-proxy configuration …<br>🤔  Verifying component health …..<br>💗  kubectl is now configured to use “minikube”<br>🏄  Done! Thank you for using minikube!</name></p><p>$ kubectl get nodes</p></blockquote><p><img src="./../pics/1554018821347-c95d911f-88cb-4a73-b226-c425a84932e8.png" alt="kubectl get pods"></p><p>可以看到， minikube 启动成功之后，用 <code>kubectl get nodes</code> 可以成功获取到 nodes 的信息，一切正常！</p><h2 id="写一个小服务，尝试部署"><a href="#写一个小服务，尝试部署" class="headerlink" title="写一个小服务，尝试部署"></a>写一个小服务，尝试部署</h2><h3 id="Hello-World-代码"><a href="#Hello-World-代码" class="headerlink" title="Hello World 代码"></a>Hello World 代码</h3><p>此处采用Go语言，因为可以静态编译且语法简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">fmt.Println(<span class="string">"Listening on http://localhost:8080/"</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello World"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>$ go run main.go<br>Listening on <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p></blockquote><p>用浏览器打开上面的网址可以看到</p><p><img src="./../pics/1554013868546-bc0e4859-0672-4173-9b5b-99326c52373d.png" alt="浏览器访问"></p><p>成功输出了 Hello World</p><p>下一步</p><h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><p>可能有人会问会什么要静态编译，不能直接 <code>go run main.go</code> 吗</p><p>如果用 <code>go run main.go</code> 来启动服务，那么还需要 Go 语言的开发环境，如果代码复杂一点还需要安装各种依赖库，会导致镜像过于庞大，因为这只是一个很小很简单的 Demo ，仅作测试的小玩具，静态编译出的可执行文件最大不到 10MB ，而为了不编译直接运行所需要的开发环境，至少都是 几百MB ，没有必要为了一个小 Demo 去浪费那么多资源，所以选择静态编译</p><blockquote><p>$ GOOS=linux CGO_ENABLED=0 go build -o main -ldflags ‘-extldflags “-static”‘ main.go</p></blockquote><p>执行这条命令后可以看到当前目录下多了一个名为 main 的可执行文件</p><p>但是不能执行，因为当前是 MacOS 环境，而静态编译时指定的是 Linux 环境</p><p>ps: 如果读者是 Linux 环境当我没说</p><p>ps: 如果有读者看不懂这条命令，没关系不要怕，你不是不懂 Golang ，你只是不懂 C 而已</p><h3 id="构建-Docker-镜像"><a href="#构建-Docker-镜像" class="headerlink" title="构建 Docker 镜像"></a>构建 Docker 镜像</h3><p>要构建 Docker 镜像，我们先写一个 dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./main /main</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"/main"</span> ]</span></span><br></pre></td></tr></table></figure><p>ps: scratch 是一个空的 Docker 镜像，即不使用基础镜像的意思</p><p>写好 Dockerfile 后，在执行命令构建镜像之前，要确保minikube已经启动，并且执行一句神奇的命令先</p><blockquote><p>$ eval $(minikube docker-env)</p></blockquote><p>在这条命令里藏着我半天的心酸，下一篇文章会仔细解释，这里先不作解释</p><p>再执行下面这些</p><blockquote><p>$ docker build -t hello:v1.0 .<br>Sending build context to Docker daemon  11.73MB<br>Step 1/3 : FROM scratch<br>—&gt;<br>Step 2/3 : ADD ./main /main<br>—&gt; 636350b5d281<br>Step 3/3 : CMD [ “/main” ]<br>—&gt; Running in a54d3c9c3864<br>Removing intermediate container a54d3c9c3864<br>—&gt; 321b69c05fff<br>Successfully built 321b69c05fff<br>Successfully tagged hello:v1.0<br>$ docker images</p></blockquote><p><img src="./../pics/1554018896187-c9afeaca-2042-42c8-aaf0-7ad775eb1c33.png" alt="docker images"></p><p>可以看到，成功地构建了镜像，笔者这里镜像大小仅仅只有 7.34MB</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>部署分为两个步骤</p><h4 id="创建-Deployments-和-Pods"><a href="#创建-Deployments-和-Pods" class="headerlink" title="创建 Deployments 和 Pods"></a>创建 Deployments 和 Pods</h4><blockquote><p>$ kubectl run hello –image=hello:v1.0 –port=8080<br>deployment.apps “hello” created<br>$ kubectl get deployments</p></blockquote><p><img src="./../pics/1554018939941-8516aaf8-b734-40ba-9e1c-4e1d66699988.png" alt="kubectl get deployments"></p><blockquote><p>$ kubectl get pods</p></blockquote><p><img src="./../pics/1554018967294-676d6ced-c2aa-4e43-8005-414c1e165a13.png" alt="kubectl get pods"></p><p>可以看到，Pods 已经准备好了</p><h4 id="创建-Service-以供外部访问"><a href="#创建-Service-以供外部访问" class="headerlink" title="创建 Service 以供外部访问"></a>创建 Service 以供外部访问</h4><blockquote><p>$ kubectl expose deployment hello –port=8080 –type=NodePort<br>service “hello” exposed<br>$ kubectl get services</p></blockquote><p><img src="./../pics/1554018998759-1009c3b7-d614-4b01-85fe-6a23fe758bdc.png" alt="kubectl get services"></p><p>可以看到，service 已经创建成功，执行以下命令来查看 service 的 ip 和端口</p><p>ps: ip和端口以自己执行命令后输出的为准</p><blockquote><p>$ minikube service hello –url<br><a href="http://192.168.99.104:31537" target="_blank" rel="noopener">http://192.168.99.104:31537</a><br>$ curl <a href="http://192.168.99.104:31537" target="_blank" rel="noopener">http://192.168.99.104:31537</a><br>Hello World</p></blockquote><p><img src="./../pics/1554017653231-56204059-016c-485a-bd07-7c6d3e6ce782.png" alt="浏览器访问"></p><p>使用浏览器打开，可以看到输出 Hello World，部署一切正常！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在部署的过程中其实遇到了很多困难，我会在接下来的一篇文章中详细说明，如果有遇到相同困难的朋友可以参考参考</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> 新开始 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2019/323.html"/>
      <url>/2019/323.html</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这是我的第一篇博客哦</p><p>刚搭建好环境，接下来就可以好好写文章啦</p><p>以后预计每周至少两篇博客，内容包括但不限于 编程经验，读书笔记，好词句积累，随笔</p><p>毕竟，这里是我的博客，独属于我自己，那就随意一点喽 :)</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针小记</title>
      <link href="/2018/24738.html"/>
      <url>/2018/24738.html</url>
      
        <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>今天写作业代码，遇到一些小问题，记录一下解决过程。</p><p>先贴出最早的问题代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// linklist.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    int          data;</span><br><span class="line">    struct node* next;</span><br><span class="line">&#125; node, *Node;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Node head = NULL, tail = NULL, p_new = NULL;</span><br><span class="line">    int temp;</span><br><span class="line">    while((scanf(&quot;%d&quot;, &amp;temp) != EOF) &amp;&amp; getchar() != &apos;\n&apos;) &#123;</span><br><span class="line">        p_new = (Node)malloc(sizeof(node));</span><br><span class="line">        p_new-&gt;data = temp;</span><br><span class="line">        if(head == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            head = p_new;</span><br><span class="line">            tail = p_new;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = p_new;</span><br><span class="line">        tail = p_new;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node max = head, p = head;</span><br><span class="line">    while(p != NULL) &#123;</span><br><span class="line">        if(p-&gt;data &gt; max-&gt;data) &#123;</span><br><span class="line">            max = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line">    while(p != NULL &amp;&amp; p-&gt;next != max) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = max-&gt;next;</span><br><span class="line">    max-&gt;next = NULL;</span><br><span class="line">    tail-&gt;next = max;</span><br><span class="line">    p = head;</span><br><span class="line">    while(p != NULL) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从控制台输入一组数据（不定量），每输入一个就插入链表尾部，输入完成后找到最大节点并将最大节点移动到链表尾部</p><p>但是在测试的时候发现不对劲，出现了无限循环</p><p>经过一系列排查，发现是因为出现了<strong>野指针</strong>！</p><p><strong>在第15行，只给<code>p_new-&gt;data</code>赋值，没有给<code>p_new-&gt;next</code>赋值，<code>p_new-&gt;next</code>成为野指针，而在后面第26行等判断指针不为<code>NULL</code>的语句始终为真，导致无限循环</strong></p><p><strong>所以修改方案就是在第15行后面添加一行<code>p_new-&gt;next = NULL;</code></strong></p><p>这一点修改之后，做测试，发现始终都不会打印出链表最后一个值</p><p><img src="./../pics/11850278-59a7d66f39a64189.png" alt="可以看到2没有了"></p><p>这就让我思考，难道是链表操作有误？</p><p>在经过一系列排查之后，再次找到问题所在</p><p><strong>第13行输入判断条件有误，<code>getchar() != &#39;\n&#39;</code> ，前面的字符后都是空格<code>&#39; &#39;</code>，但最后一个数后面的字符是<code>&#39;\n&#39;</code>，于是表达式为假，于是就没有后面的循环了，最后一个数也自然没加进链表</strong></p><p><strong>改进方法就是将循环改成下面这样</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">while(scanf(&quot;%d&quot;, &amp;temp)) &#123;</span><br><span class="line">    p_new = (Node)malloc(sizeof(node));</span><br><span class="line">    p_new-&gt;data = temp;</span><br><span class="line">    p_new-&gt;next = NULL;</span><br><span class="line">    if(head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        head = p_new;</span><br><span class="line">        tail = p_new;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = p_new;</span><br><span class="line">    tail = p_new;</span><br><span class="line">    if(getchar() == &apos;\n&apos;) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就不会有问题啦<br><img src="./../pics/11850278-677c760628baf929.png" alt="一切正常"></p><p>所以这次问题小记就到这里啦</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Summary </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言动态链接与静态链接</title>
      <link href="/2018/24568.html"/>
      <url>/2018/24568.html</url>
      
        <content type="html"><![CDATA[<p>个人很看重编译和链接这层的东西，简单谈一谈C语言的动态链接和静态链接</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在做程序开发的时候，有许多简单的函数是很常用的，但是如果每个程序都把这些很常用的函数的实现包含在内的话，就会占用很多空间</p><p>有一个很好的办法，把这些常用的函数实现提取成单独的文件（动态链接库），放在某个地方，一个程序需要使用某个函数的时候再去加载对应的库，这样就能节省很多空间</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// main.c</span><br><span class="line">void hello();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    hello();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void hello()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello World from hello.c\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译测试一下<br><code>gcc main.c hello.c -o main &amp;&amp; ./main</code><br><img src="./../pics/11850278-e3e7e8477dccc727.png" alt="正常输出，没毛病"></p><p>接下来将<code>hello.c</code>编译成动态链接库试一试<br><code>gcc hello.c -shared -o libhello.so</code><br><img src="./../pics/11850278-9787cdc61297192a.png" alt></p><p>可以看到编译出了<code>libhello.so</code></p><p>接下来编译<code>main.c</code>，并且制定使用<code>libhello</code>这个库，在当前目录查找库文件<br><code>gcc main.c -lhello -L. -o main</code><br><img src="./../pics/11850278-7576b1c2f84901e8.png" alt></p><p>运行一下试试</p><p><img src="./../pics/11850278-4cb2d8036b04454a.png" alt="没毛病"></p><p>试试把<code>libhello.so</code>的名字改了，或者移动到其他地方，让<code>main</code>找不到动态库<br><img src="./../pics/11850278-d6947296942c5c24.png" alt="可以看到，程序的确找不到库了，不能正常输出"></p><p>可以很明确的看出，程序是在运行时动态加载<code>libhello.so</code>库的，如果这个库被移动或者改名了，程序就不能正常运行</p><p>用ldd命令看看动态库的依赖<br><code>ldd ./main</code><br><img src="./../pics/11850278-8d6fd46576008c86.png" alt="可以看到这个程序的几个动态依赖"></p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>静态链接就是直接把所有运行时需要的库，全部包含进程序中，打包在一起，这样就不管外面的库怎么移动怎么改名怎么缺少，程序都可以运行</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>还是之前的代码，将<code>hello.c</code>编译，但是不作链接<br><code>gcc -c hello.c -o hello.o &amp;&amp; ll</code><br><img src="./../pics/11850278-3a700992478f51b2.png" alt="生成的hello.o"></p><p>再把<code>hello.o</code>打包成静态库文件<br><code>ar -r libhello.a hello.o &amp;&amp; ll</code><br><img src="./../pics/11850278-c222fafabc2e7b24.png" alt="生成的静态库文件"></p><p>再来编译<code>main.c</code>并且把<code>libhello.a</code>静态链接进程序中<br><code>gcc main.c -lhello -L. -static -o main_static</code><br><img src="./../pics/11850278-8ea164963b49bdef.png" alt></p><p>运行结果一切正常，并且跟静态库已经没有关系了，删掉静态库程序依然可以运行<br><img src="./../pics/11850278-63b2d9f30852fc42.png" alt="可以看出差别在哪"></p><p>用<code>ldd</code>命令看看<br><code>ldd ./main_static</code><br><img src="./../pics/11850278-e79bedeb9b78513e.png" alt="哈，不是个动态可执行文件"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>没有小结，自己看书去！</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要在Linux上学习C语言</title>
      <link href="/2018/57868.html"/>
      <url>/2018/57868.html</url>
      
        <content type="html"><![CDATA[<p>以下内容节选自<br>宋劲杉 的 《Linux C编程一站式学习》</p><p>为什么要在Linux平台上学C语言？</p><p>用Windows学C语言不好吗？用Windows还真的是学不好C语言。</p><p>C语言是一种面向底层的编程语言，要写好C程序，必须对操作系统的工作原理非常清楚，因为操作系统也是用C写的，我们用C写应用程序直接使用操作系统提供的接口。</p><p>既然你选择了看这本书，你一定了解：Linux是一种开源的操作系统，你有任何疑问都可以从源代码和文档中找到答案，即使你看不懂源代码，也找不到文档，也很容易找个高手教你，各种邮件列表、新闻组和论坛上从来都不缺乐于助人的高手；而Windows是一种封闭的操作系统，除了微软的员工别人都看不到它的源代码，只能通过文档去猜测它的工作原理，更糟糕的是，微软向来喜欢藏着揶着，好用的功能留着自己用，而不会写到文档里公开。本书的第一部分在Linux或Windows平台上学习都可以，但第二部分和第三部分介绍了很多Linux操作系统的原理以帮助读者更深入地理解C语言，只能在Linux平台上学习。</p><p><strong>Windows平台上的开发工具往往和各种集成开发环境（IDE，Integrated Development Environment）绑在一起，例如Visual Studio、Eclipse等。使用IDE确实很便捷，但IDE对于初学者绝对不是好东西。微软喜欢宣扬傻瓜式编程的理念，告诉你用鼠标拖几个控件，然后点一个按钮就可以编译出程序来，但是真正有用的程序有哪个是这么拖出来的？很多从Windows平台入门学编程的人，编了好几年程序，还是只知道编完程序点一个按钮就可以跑了，把几个源文件拖到一个项目里就可以编译到一起了，如果有更复杂的需求他们就傻眼了，因为他们脑子里只有按钮、菜单的概念，根本没有编译器、链接器、Makefile的概念，甚至连命令行都没用过，然而这些都是初学编程就应该建立起来的基本概念。另一方面，编译器、链接器和C语言的语法有密切的关系，不了解编译器、链接器的工作原理，也不可能真正掌握C的语法。所以，IDE并没有帮助你学习，而是阻碍了你学习，本来要学好C编程只要把语法和编译命令学会就行了，现在有了IDE，除了学会语法和编译命令，你还得弄清楚编译命令和IDE是怎么集成的，这才算学明白了，本来就很复杂的学习任务被IDE搞得更加复杂了。</strong></p><p>Linux用户的使用习惯从来都是以敲命令为主，以鼠标操作为辅，从学编程的第一天起就要敲命令编译程序，等到你把这些基本概念都搞清楚了，你觉得哪个IDE好用你再去用，不过到那时候你可能会更喜欢<code>vi</code>或<code>emacs</code>而不是IDE了。</p>]]></content>
      
      
      <categories>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Programming </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机迷宫生成和寻路</title>
      <link href="/2018/19742.html"/>
      <url>/2018/19742.html</url>
      
        <content type="html"><![CDATA[<p>最近学习了一些数据结构相关的东西，想要多练练，于是写了个随机迷宫生成和自动寻路，为了实现可视化，使用了C++的easyx图形库</p><p>使用Kruskal算法生成迷宫，DFS搜索路径。</p><p>不多说，贴代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// graphic.h</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;easyx.h&gt;</span><br><span class="line">#include &lt;graphics.h&gt;</span><br><span class="line"></span><br><span class="line">#define LEN 20</span><br><span class="line">#define NUM (LEN * LEN)</span><br><span class="line">#define MAZELEN (LEN * 2 - 1)</span><br><span class="line">#define LINELENGTH 40</span><br><span class="line">#define WID (21 * LINELENGTH)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Gra</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Gra();</span><br><span class="line">~Gra();</span><br><span class="line">bool connected(int a, int b);</span><br><span class="line">int find(int a);</span><br><span class="line">void unio(int a, int b);</span><br><span class="line">private:</span><br><span class="line">int id[NUM];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// graphic.cpp</span><br><span class="line">#include &quot;graphic.h&quot;</span><br><span class="line"></span><br><span class="line">Gra::Gra()</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;id[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Gra::~Gra()</span><br><span class="line">&#123;</span><br><span class="line">//donothing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Gra::find(int a)</span><br><span class="line">&#123;</span><br><span class="line">int fa = this-&gt;id[a];</span><br><span class="line">while (fa != id[fa])</span><br><span class="line">&#123;</span><br><span class="line">fa = id[fa];</span><br><span class="line">&#125;</span><br><span class="line">return fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Gra::unio(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;id[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Gra::connected(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">int fa = this-&gt;find(a);</span><br><span class="line">int fb = this-&gt;find(b);</span><br><span class="line">if (fa != fb)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;unio(fa, fb);</span><br><span class="line">int ai = a / LEN;</span><br><span class="line">int aj = a % LEN;</span><br><span class="line">int bi = b / LEN;</span><br><span class="line">int bj = b % LEN;</span><br><span class="line">line(ai * LINELENGTH, aj * LINELENGTH, bi * LINELENGTH, bj * LINELENGTH);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">// main.cpp</span><br><span class="line">#include &quot;graphic.h&quot;</span><br><span class="line"></span><br><span class="line">#define ROAD 0</span><br><span class="line">#define WALL 1</span><br><span class="line">#define STARTNUM 2</span><br><span class="line">#define ENDNUM 3</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">Gra *g = new Gra();</span><br><span class="line">std::vector&lt;Point&gt; tem;</span><br><span class="line">std::stack&lt;Point&gt; st;</span><br><span class="line">int maze[MAZELEN][MAZELEN];</span><br><span class="line">for (int i = 0; i &lt; MAZELEN; i++)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; MAZELEN; j++)</span><br><span class="line">&#123;</span><br><span class="line">maze[i][j] = WALL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; LEN; i++)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; LEN; j++)</span><br><span class="line">&#123;</span><br><span class="line">int p = i * LEN + j;</span><br><span class="line">if (i &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">Point pp;</span><br><span class="line">pp.x = p;</span><br><span class="line">pp.y = p - LEN;</span><br><span class="line">tem.push_back(pp);</span><br><span class="line">&#125;</span><br><span class="line">if (j &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">Point pp;</span><br><span class="line">pp.x = p;</span><br><span class="line">pp.y = p - 1;</span><br><span class="line">tem.push_back(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srand((unsigned)time(NULL));</span><br><span class="line">int n = rand() % 5;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">std::random_shuffle(tem.begin(), tem.end());</span><br><span class="line">&#125; while (n--);</span><br><span class="line"></span><br><span class="line">initgraph(WID, WID);</span><br><span class="line">setorigin(LINELENGTH, LINELENGTH);</span><br><span class="line">LINESTYLE ls;</span><br><span class="line">getlinestyle(&amp;ls);</span><br><span class="line">ls.thickness = LINELENGTH / 2;</span><br><span class="line">ls.style = ls.style | PS_ENDCAP_SQUARE;</span><br><span class="line">setlinestyle(&amp;ls);</span><br><span class="line">for (int i = 0; i &lt; LEN; i++)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; LEN; j++)</span><br><span class="line">&#123;</span><br><span class="line">putpixel(i * LINELENGTH, j * LINELENGTH, WHITE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; tem.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">int a = tem[i].x;</span><br><span class="line">int b = tem[i].y;</span><br><span class="line">if (g-&gt;connected(a, b))</span><br><span class="line">&#123;</span><br><span class="line">tem[i].x = -1;</span><br><span class="line">tem[i].y = -1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">int ai = a / LEN;</span><br><span class="line">int aj = a % LEN;</span><br><span class="line">int bi = b / LEN;</span><br><span class="line">int bj = b % LEN;</span><br><span class="line">if (ai == bi)</span><br><span class="line">&#123;</span><br><span class="line">int min = aj &lt; bj ? aj : bj;</span><br><span class="line">int max = aj &gt; bj ? aj : bj;</span><br><span class="line">min *= 2;</span><br><span class="line">max *= 2;</span><br><span class="line">for (int j = min; j &lt;= max; j++)</span><br><span class="line">&#123;</span><br><span class="line">maze[ai * 2][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (aj == bj)</span><br><span class="line">&#123;</span><br><span class="line">int min = ai &lt; bi ? ai : bi;</span><br><span class="line">int max = ai &gt; bi ? ai : bi;</span><br><span class="line">min *= 2;</span><br><span class="line">max *= 2;</span><br><span class="line">for (int j = min; j &lt;= max; j++)</span><br><span class="line">&#123;</span><br><span class="line">maze[j][aj * 2] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Sleep(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ls.thickness = 5;</span><br><span class="line">setlinestyle(&amp;ls);</span><br><span class="line">setlinecolor(RED);</span><br><span class="line"></span><br><span class="line">bool marked[MAZELEN][MAZELEN];</span><br><span class="line">memset(marked, false, sizeof(marked));</span><br><span class="line">Point start, end;</span><br><span class="line">start.x = MAZELEN - 1;</span><br><span class="line">start.y = 0;</span><br><span class="line">end.x = 0;</span><br><span class="line">end.y = 0;</span><br><span class="line">st.push(start);</span><br><span class="line">Point p;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">p = st.top();</span><br><span class="line">if (p.x == end.x &amp;&amp; p.y == end.y)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if ((p.x &lt; MAZELEN - 1) &amp;&amp; !marked[p.x + 1][p.y] &amp;&amp; (maze[p.x + 1][p.y] == ROAD))</span><br><span class="line">&#123;</span><br><span class="line">Point t;</span><br><span class="line">t.x = p.x + 1;</span><br><span class="line">t.y = p.y;</span><br><span class="line">marked[t.x][t.y] = 1;</span><br><span class="line">st.push(t);</span><br><span class="line">line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);</span><br><span class="line">&#125;</span><br><span class="line">else if ((p.y &lt; MAZELEN - 1) &amp;&amp; !marked[p.x][p.y + 1] &amp;&amp; (maze[p.x][p.y + 1] == ROAD))</span><br><span class="line">&#123;</span><br><span class="line">Point t;</span><br><span class="line">t.x = p.x;</span><br><span class="line">t.y = p.y + 1;</span><br><span class="line">marked[t.x][t.y] = 1;</span><br><span class="line">st.push(t);</span><br><span class="line">line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);</span><br><span class="line">&#125;</span><br><span class="line">else if ((p.x &gt; 0) &amp;&amp; !marked[p.x - 1][p.y] &amp;&amp; (maze[p.x - 1][p.y] == ROAD))</span><br><span class="line">&#123;</span><br><span class="line">Point t;</span><br><span class="line">t.x = p.x - 1;</span><br><span class="line">t.y = p.y;</span><br><span class="line">marked[t.x][t.y] = 1;</span><br><span class="line">st.push(t);</span><br><span class="line">line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);</span><br><span class="line">&#125;</span><br><span class="line">else if ((p.y &gt; 0) &amp;&amp; !marked[p.x][p.y - 1] &amp;&amp; (maze[p.x][p.y - 1] == ROAD))</span><br><span class="line">&#123;</span><br><span class="line">Point t;</span><br><span class="line">t.x = p.x;</span><br><span class="line">t.y = p.y - 1;</span><br><span class="line">marked[t.x][t.y] = 1;</span><br><span class="line">st.push(t);</span><br><span class="line">line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Point t = st.top();</span><br><span class="line">st.pop();</span><br><span class="line">p = st.top();</span><br><span class="line">setlinecolor(WHITE);</span><br><span class="line">line(p.x * LINELENGTH / 2, p.y * LINELENGTH / 2, t.x * LINELENGTH / 2, t.y * LINELENGTH / 2);</span><br><span class="line">setlinecolor(RED);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">closegraph();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果自己跑着玩吧，反正我编译通过了。//逃</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单读写进程内存</title>
      <link href="/2018/24479.html"/>
      <url>/2018/24479.html</url>
      
        <content type="html"><![CDATA[<p>为什么会有这样一篇博客呢，读写进程内存，<del>谁没事了干这种事情啊</del>。这个呢，还得从我最早接触编程说起。</p><p>以前，我还是个网瘾青年，喜欢玩地下城与勇士这款网络游戏，无奈自己又没有人民币，装备又不好，玩起来特别没劲。偶然一次接触到了一个开外挂的人，带我，然后介绍给我一些免费外挂。于是我就接触到了外挂这种东西，发现地下城与勇士这款游戏的许多外挂都是由一个叫做易语言的编程语言写出来的，于是，我接触到了易语言，刚接触什么都不会，只会抄袭别人的外挂源码(抄袭可耻)。把进程名换成其他进程的名字，就能够修改其他进程的数据，然后地址栏，修改成不同的地址，就能修改不同地址的数据，当时觉得特别神奇，好奇心害死猫，于是我开始学习编程，最开始还是在学习易语言，因为它是全中文编程。而且可以很简单的做出一个窗口，按钮等等，而不是刚接触C语言时的一堆黑框，创建窗口还要先注册窗口类，实例化窗口，显示窗口什么的。。。</p><p>用易语言写一个外挂可太简单了，可当我正规的读到了大学，进入了计算机系，正规的学习了其他编程语言后。才知道其实易语言是封装的C++语言，易语言能够实现的，C++都可以实现，<del>确切的来说，C++是万能的</del>。</p><p>记得当时最有印象的几个函数名字是，十六到十，写内存整数型，写内存字节集等等，其实就是简单的把内存地址十六进制转成十进制，修改内存数据什么的，或者还有键盘监视和hook之类的就不谈了，这又是一个大话题。</p><p>读写进程内存在易语言中很好实现，几个文字，写参数就行了，其实在C++中也并不复杂，只要有相应的API就行了，于是在MSDN查询到了两个API，<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85" target="_blank" rel="noopener">ReadProcessMemory</a>.aspx) 和 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674(v=vs.85" target="_blank" rel="noopener">WriteProcessMemory</a>.aspx) ，可以点击进入MSDN看详细的解释。这里只作简单介绍<br><img src="./../pics/11850278-d413a93f0f9c3bf5.png" alt="ReadProcessMemory函数原型"><br><img src="./../pics/11850278-044f92cc83d2e3c4.png" alt="WriteProcessMemory函数原型"><br>可以看到，这两个函数很相似，都接受五个参数，</p><ol><li>读取（写入）数据的进程句柄</li><li>要读取（写入）的地址</li><li>读取到（用作写入）的数据的存放指针</li><li>希望读取（写入）的大小</li><li>实际读取（写入）的大小的存放指针</li></ol><p>返回值：执行成功时，返回非0值，出错了返回0</p><p>进程句柄需要通过<code>OpenProcess</code>函数或者<code>CreateProcess</code>函数返回，这里时读取（写入）其他进程而非子进程，使用<code>OpenProcess</code>，我先写一个小程序来做<strong>被修改</strong>程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int count = 10, num = 0;</span><br><span class="line">while(count--)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;count = %d, num = %d\nInput a number to update num\n&quot;, count, num);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;count &lt; 0, Process end, press enter to close console\n&quot;);</span><br><span class="line">getchar();</span><br><span class="line">getchar();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行后<img src="./../pics/11850278-c47dda9ad327a2b3.png" alt><br>很清楚的显示了每个变量的值，方便我们去检验后面读取到的值是否正确或者是否成功修改，先放到一边。</p><p>开始写读取和写入进程内存的程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt; // 上面提到的API都是在这里声明的</span><br><span class="line">#include &lt;cstdio&gt; // C标准IO库</span><br><span class="line">#include &lt;cstdlib&gt; // C标准库</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">DWORD pid = (DWORD)8512; // 进程PID，可通过任务管理器查看，自行修改成被修改程序的PID</span><br><span class="line">HANDLE handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); // 获得进程句柄</span><br><span class="line">if (handle == INVALID_HANDLE_VALUE) // 出错就报错和退出</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;OpenProcess failed\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int address = 0x0061FE4C; // 要读取和修改的内存地址，可以通过CheatEngine获取，这里是变量count的地址</span><br><span class="line">int *p = (int*)malloc(sizeof(int)); // 动态申请内存(似乎不动态申请会报错，不懂为啥)</span><br><span class="line">DWORD len = 0;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">if (ReadProcessMemory(handle, (LPCVOID)address, p, sizeof(int), &amp;len)) // 读取</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Read a number: %d\n&quot;, *p); // 打印出读取到的值</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Input a number to write in memory\n&quot;); </span><br><span class="line">scanf_s(&quot;%d&quot;, p); // 输入用作写入的值</span><br><span class="line">if (WriteProcessMemory(handle, (LPVOID)address, p, sizeof(int), &amp;len)) // 写入</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Write success\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 以上代码在 Windows10专业版 VisualStudio 2017 专业版编译通过</span><br></pre></td></tr></table></figure></p><p>编译运行<br><img src="./../pics/11850278-8f3f06bda292be35.png" alt="第一次读取count"><br>可以看到，成功的读取到了变量count的值，再试试修改count的值，输入1234，回车<br><img src="./../pics/11850278-8310f18a48843883.png" alt="写入count并再次读取"><br>修改成功了！从另一个程序看看</p><p><img src="./../pics/11850278-42202d68bc27ecdf.png" alt="被修改程序打印count的值作检测"><br>果然修改成功了！！！多么激动人心，count 自减了一次，再读取一下试试</p><p><img src="./../pics/11850278-d291aa0a94c9c739.png" alt><br><br>至此，很简单的内存读写就实现了，多使用这几个API，就可以熟练的去修改一些内存中的值啦，可以用C++做一些小游戏的外挂了哦。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针声明小结</title>
      <link href="/2018/3357.html"/>
      <url>/2018/3357.html</url>
      
        <content type="html"><![CDATA[<p>博客开了这么久，都没写什么技术性的文章，恰好最近在看C语言相关的东西，学会一些关于指针声明的小技巧，记录一下。<br>言传我也不太说话，直接意会吧</p><h4 id="变量指针"><a href="#变量指针" class="headerlink" title="变量指针"></a>变量指针</h4><blockquote><p><strong>int *p = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>整形变量</em> 的指针</strong><br><strong>int **p = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>整形指针变量</em> 的指针</strong></p></blockquote><h4 id="常量指针，常指针"><a href="#常量指针，常指针" class="headerlink" title="常量指针，常指针"></a>常量指针，常指针</h4><blockquote><p><strong>const int *p = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>整形常量</em> 的指针</strong><br><strong>int *const p = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>整形</em> 的常指针</strong><br><strong>const int *const p = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>整形常量</em> 的常指针</strong></p></blockquote><h4 id="数组指针，指针数组"><a href="#数组指针，指针数组" class="headerlink" title="数组指针，指针数组"></a>数组指针，指针数组</h4><blockquote><p><strong>int *p[4] = {NULL};&nbsp;&nbsp;//&nbsp;大小为4的数组，每个元素都是指向整形变量的指针</strong><br><strong>int (*p)[4] = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>一个大小为4的整形数组</em> 的指针，自增时每次加4 * sizeof(int)</strong><br><strong>int *(*p)[4] = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>一个大小为4的指针数组</em> ，该数组的每一个元素都是指向整形变量的指针</strong><br><strong>int *p[3][4] = {NULL};&nbsp;&nbsp;//&nbsp;3 * 4的二维数组，每一个元素都是指向整形变量的指针</strong><br><strong>int (*p)[3][4] = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>大小为3 \</em> 4的二维整形数组<em> 的指针，自增时每次加3 \</em> 4 * sizeof(int)</strong><br><strong>int *(*p)[3][4] = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>大小为3 \</em> 4的二维整形指针数组* 的指针，该数组每一个元素都是指向整形变量的指针</strong><br><strong>int (*(*p)[3])[4] = NULL;&nbsp;&nbsp;//&nbsp;指向一个指针，这个指针又指向一个大小为3的指针数组，数组的每一个元素指向一个大小为4的整形数组</strong><br><strong>int *(*(*p)[3])[4] = NULL;&nbsp;&nbsp;//&nbsp;指向一个指针，这个指针又指向一个大小为3的指针数组，数组的每一个元素指向一个大小为4的整形指针数组</strong></p></blockquote><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><blockquote><p><strong>int *p(int) = NULL;&nbsp;&nbsp;//&nbsp;有一个整形形参，返回值为整形指针的函数</strong><br><strong>int (*p)(int) = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>有一个整形形参，返回值为整形变量的函数</em> 的函数指针</strong><br><strong>int *(*p)(int) = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>有一个整形形参，返回值为整形指针的函数</em> 的函数指针</strong><br><strong>int *(*p)(int*) = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>有一个整形指针参数，返回值是整形指针的函数</em> 的函数指针</strong><br><strong>int *(*p)(int, int*) = NULL;&nbsp;&nbsp;//&nbsp;指向 <em>有一个整形参数，一个整形指针参数，返回值是整形指针的函数</em> 的函数指针</strong></p></blockquote><h4 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h4><blockquote><p><strong>int *(*(*(*p)(int*))[3])(int*[ ], int*) = NULL;&nbsp;&nbsp;//&nbsp;P是一个函数指针，指向一个有一个整形指针参数的函数，这个函数的返回值是指向数组的指针，数组的每一个元素也是一个函数指针，指向一个 返回值为整形指针，参数为一个整形指针数组和一个整形指针 的函数</strong></p></blockquote><p><br></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>稍微有点乱，但是，不难发现其中的规律。</p><p><strong>*p表示一个指针，但是 * 符号的优先级没有( )和[ ]高。所以 int *p[ ] 和 int (*p)[ ] 就有一些区别了，一个是 指针数组，一个是数组指针</strong><br><br><br><strong>int *p[ ];&nbsp;&nbsp;[ ]优先级比*高，所以p是数组，那么把p[]用手遮住，剩下的就是数组的类型了，也就是int*，整形指针类型。</strong><br><br><br><strong>int (*p)[ ];&nbsp;&nbsp;*p被括号括起来了，优先级最高，所以p是指针，用手把*p遮住，剩下的就是指针所指向的类型了，也就是int [ ]，整形数组类型。</strong><br><br><br>那么，同样的方法，可以分析一下其他的声明。如<strong>int *p(int);和int (*p)(int);</strong><br><br><br><strong>int *p(int); &nbsp;乍一看像一个指针，但是这是一个函数声明，( )优先级比*高，所以p是一个函数，所以把p(int)遮住，剩下int*，所以p是一个参数为整形，返回值为整形指针的函数。</strong><br><br><br><strong>int (*p)(int); &nbsp;这个就是一个指针声明了，p是指针，遮住(*p)，剩下int &nbsp; (int)，所以p指向 &nbsp; 一个参数为整形，返回值为整形&nbsp; 的函数。</strong><br><br><br><br><del>方法就是这么个方法，其他分析自己多思考吧。</del></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Summary </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo+GitHub搭建个人博客教程</title>
      <link href="/2018/43234.html"/>
      <url>/2018/43234.html</url>
      
        <content type="html"><![CDATA[<p>既然我已经搭建了个人博客，就想要把方法也分享给我的朋友们，让朋友们也能搭建一个自己的博客<del>(提升逼格)</del>。不多说，下面就是教程。</p><h4 id="基础需求"><a href="#基础需求" class="headerlink" title="基础需求"></a>基础需求</h4><p>联网的电脑一台，以下教程仅以Windows操作系统做示范<br>GitHub账号一个，如果没有账号可前往<a href="https://github.com" target="_blank" rel="noopener">GitHub官网</a>免费注册<br>域名一个（也可以不用）， 可前往<a href="https://cn.aliyun.com" target="_blank" rel="noopener">阿里云</a>进行域名注册</p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><h5 id="NodeJs-的安装"><a href="#NodeJs-的安装" class="headerlink" title="NodeJs 的安装"></a>NodeJs 的安装</h5><p>打开<a href="https://nodejs.org" target="_blank" rel="noopener">NodeJs官网</a>后<img src="./../pics/11850278-8b5977e42b6622f2.png" alt>点击DOWNLOADS后可见到如下界面<img src="./../pics/11850278-c0248b3c7363f27e.png" alt><br>下载自己对应平台的NodeJs，进行安装，安装完成后打开命令提示符或者终端，输入</p><blockquote><p>node -v</p></blockquote><p>如果输出NodeJs的版本号，参见下图<img src="./../pics/11850278-16e3cbac93971cf7.png" alt><br>说明安装NodeJs成功。</p><h5 id="Hexo的安装及博客搭建"><a href="#Hexo的安装及博客搭建" class="headerlink" title="Hexo的安装及博客搭建"></a>Hexo的安装及博客搭建</h5><p>打开命令行,确保电脑接入网络，输入</p><blockquote><p>npm install -g hexo-cli</p></blockquote><p>等待一两分钟<img src="./../pics/11850278-8373d7467605e9e7.png" alt><br>如图安装完成后，再输入</p><blockquote><p>cd desktop</p></blockquote><p>把命令提示符的工作目录设置到桌面上，再输入</p><blockquote><p>hexo init myblog</p></blockquote><p>出现如图<img src="./../pics/11850278-f02664d93440ed5b.png" alt><br>说明初始化成功，可以见到桌面上多了一个名为myblog的文件夹<img src="./../pics/11850278-34e8e3267e494a04.png" alt><br>再在命令行输入</p><blockquote><p>cd myblog<br>hexo generate<br>hexo server</p></blockquote><p><img src="./../pics/11850278-4b50e3cab0b74818.png" alt>如果如图所示，说明博客初步搭建成功了，可以打开浏览器输入网址<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> <img src="./../pics/11850278-4d50f9bd8ca554d5.png" alt>可见到如图的页面，不过这还只是本地的，接下来就来让它可以被外网访问。</p><h5 id="GitHub仓库创建"><a href="#GitHub仓库创建" class="headerlink" title="GitHub仓库创建"></a>GitHub仓库创建</h5><p>首先，你需要一个GitHub的账号，如果没有账号可以自己注册，此处省略注册教程，打开<a href="https://github.com" target="_blank" rel="noopener">GitHub官网</a>，登陆账号，进入页面后点击<img src="./../pics/11850278-c8e314fdaebc1376.png" alt>创建仓库用以存放博客，输入仓库名称为</p><blockquote><p><strong>你的GitHub用户名</strong>.github.io</p></blockquote><p>例如我的用户名是Zeng1999,就输入<img src="./../pics/11850278-73e71457f501e3c6.png" alt>然后点击下面的<img src="./../pics/11850278-32523a8f29812acc.png" alt>创建仓库。创建完成后就开始Git的安装。</p><h5 id="Git的安装及配置"><a href="#Git的安装及配置" class="headerlink" title="Git的安装及配置"></a>Git的安装及配置</h5><p>Git是一个开源的分布式版本控制系统，我们可以使用Git将网站同步到GitHub上。<br>可到<a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a>进行下载和安装，这里不再赘述。<br>安装完成后，在桌面单击右键<img src="./../pics/11850278-98d52f2831ff0701.png" alt>点击Git Bash Here<img src="./../pics/11850278-cc9522efbd10d905.png" alt>输入</p><blockquote><p>git config –global user.name <strong>你的GitHub用户名</strong><br>git config –global user.email <strong>你的GitHub注册邮箱</strong></p></blockquote><p>生成密钥文件：</p><blockquote><p>ssh-keygen -t rsa -C <strong>你的GitHub注册邮箱</strong></p></blockquote><p>提示输入保存目录，回车使用默认目录即可<br>提示输入密码短语，输完后回车<br>提示再次输入密码短语，输入相同的密码后回车<br>密钥生成完成，可在用户目录下的.ssh文件夹下找到 id_rsa.pub 公钥<img src="./../pics/11850278-31aad8a628bda58e.png" alt>右键以文本形式打开，复制其中的全部内容后关闭<br>打开GitHub，点击自己头像-settings<img src="./../pics/11850278-30c62dd7516b0b02.png" alt>再在左边找到SSH and GPG keys这一项<img src="./../pics/11850278-68503e1cb59f56fa.png" alt>找到New SSH key<img src="./../pics/11850278-b2449c1411df373d.png" alt>点击，标题可任意，把刚才复制的粘贴到key栏中再点击 Add SSH key<img src="./../pics/11850278-c7e47ff4180167f0.png" alt><br>添加完成后再打开Git Bash，输入</p><blockquote><p>ssh <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p></blockquote><p>如果出现<img src="./../pics/11850278-9448ae6ee4f8b611.png" alt>则表明密钥可用，能连接上GitHub了。</p><h5 id="外网部署"><a href="#外网部署" class="headerlink" title="外网部署"></a>外网部署</h5><p>找到之前在桌面上生成的文件夹myblog<img src="./../pics/11850278-f54cad34d882fbe8.png" alt>打开，找到一个名为_config.yml的文件<img src="./../pics/11850278-6fe4a5c7692beb26.png" alt>用文本编辑器打开，找到最后的几行<img src="./../pics/11850278-d26f8ad1776f8212.png" alt>改成如图，图中<strong>红框部分修改为你的GitHub用户名</strong><img src="./../pics/11850278-f6b15adc17b4bbc0.png" alt>修改完后保存并关闭文本编辑器。<br>打开桌面上的myblog文件夹，按住shift单击右键，点击在此处打开power shell窗口 或者 在此处打开命令提示符，再打开的窗口输入</p><blockquote><p>npm install hexo-deployer-git –save<br>hexo clean<br>hexo generate<br>hexo deploy</p></blockquote><p>出现如图提示，部署到GitHub成功<img src="./../pics/11850278-c35015386db523ca.png" alt><br>激动人心的时刻到了，打开浏览器打开网址 <strong>你的GitHub用户名.github.io</strong> <img src="./../pics/11850278-b9f083a49c4ceae3.png" alt><br>出现博客主页，部署完成，可从外网访问你的博客了</p><h5 id="使用个性域名"><a href="#使用个性域名" class="headerlink" title="使用个性域名"></a>使用个性域名</h5><p>首先，你需要有一个域名，可以到<a href="https://cn.aliyun.com" target="_blank" rel="noopener">阿里云</a>进行域名注册，具体操作就不演示了，我已经有了一个域名，下面演示如何通过个性域名访问到个人博客。<br>打开GitHub，打开博客的仓库，点击设置<img src="./../pics/11850278-21444fd7584e357d.png" alt>找到下面这一行<img src="./../pics/11850278-f5bb8fdfed48f9eb.png" alt>输入你的域名后点击Save保存。</p><p>设置域名解析，以阿里云为例，进入控制台，找到云解析DNS，点击要用作博客的域名<img src="./../pics/11850278-41cdc404e9b190e7.png" alt>然后点击 添加解析<img src="./../pics/11850278-aa9f7629d632251e.png" alt> <img src="./../pics/11850278-8048d5f95e69e5cf.png" alt>把红框内的修改为你的GitHub用户名，点击确认。</p><p>打开MyBlog文件夹，打开其中的source文件夹，新建一个文本文档，重命名为<strong>CNAME（无后缀名）</strong><img src="./../pics/11850278-9f56222a068c8ca7.png" alt>然后用文本编辑器打开，输入你的域名，保存关闭即可<img src="./../pics/11850278-af342c9b75a0818e.png" alt>至此，域名设置就完成了。在MyBlog文件夹下打开命令行，输入</p><blockquote><p>hexo generate<br>hexo deploy</p></blockquote><p>打开浏览器，访问你的个人博客吧！</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
