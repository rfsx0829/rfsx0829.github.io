<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于 RSS</title>
      <link href="/2019/418.html"/>
      <url>/2019/418.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于-RSS"><a href="#关于-RSS" class="headerlink" title="关于 RSS"></a>关于 RSS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>刚才突然想了很多事情，突然想到之前在日记中有提到，每周要写总结，并且放到博客上。</p><p>所以，这周的总结，肯定是有的，但因为刚开始，内容可能会非常贫乏，还在摸索道路</p><p>又想到之前我BOSS一年前提到的，关于rss的东西，那时候我刚入门，他让我做一个这方面的应用，但当时的我水平还不足以做到，现在来试试</p><p>所以，这篇文章来讲讲关于RSS的东西，并且我自己又建了一个代码库，尽量完成这个项目</p><h2 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h2><p>RSS 即 Really Simple Syndication 简易信息聚合，其实就是一个 信息源</p><p>那么这个项目具体要做什么呢，做一个 RSS 阅读器，虽然已经有很多现成的阅读器了，但我还是要做，因为。。。算是弥补一下以前没能做成这个项目的遗憾吧</p><p>可能还是有读者不理解什么叫做rss，没事，等这篇文章有除我之外的其他读者的时候，可能我这个项目早就做好最初版本了哈，到时候你们自己下载来玩玩就知道了</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>这里是项目的链接 <a href="https://github.com/rfsx0829/rss" target="_blank" rel="noopener">rss reader</a></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>因为这篇文章只是讲一下我要做一个这个项目，实际还没有动工，那么在这里就可以展望一下这个项目需要有什么功能</p><h3 id="功能展望"><a href="#功能展望" class="headerlink" title="功能展望"></a>功能展望</h3><ol><li>阅读聚合消息</li><li>添加，删除源</li><li>优质源推荐</li></ol><p>暂定这三个基础功能吧，高级功能后期再添加</p><h3 id="项目形式"><a href="#项目形式" class="headerlink" title="项目形式"></a>项目形式</h3><p>暂定 Golang 后台 + Flutter APP ，等这两个都完工可以考虑再做一个 Web 前端</p>]]></content>
      
      
      <categories>
          
          <category> Projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSS </tag>
            
            <tag> APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful 架构</title>
      <link href="/2019/414.html"/>
      <url>/2019/414.html</url>
      
        <content type="html"><![CDATA[<h1 id="RESTful-架构"><a href="#RESTful-架构" class="headerlink" title="RESTful 架构"></a>RESTful 架构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓 REST，即是 Resources Representational State Transfer 的缩写，即 资源表现层状态转化</p><p>具体怎么理解，我看了 阮一峰 大神的博客，<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">点击这里查看文章</a>，我觉得解释得很清楚</p><p>那为什么还要写这篇博客呢，我是想记录一下自己的感受和见解</p><h2 id="最初的理解"><a href="#最初的理解" class="headerlink" title="最初的理解"></a>最初的理解</h2><p>最早看到 RESTful 这个词，还是在以前学 Nodejs 的时候，看 Eggjs 框架，文档中有提到这个概念，但是当时一点都不懂，也没有查资料，以自己粗浅的知识瞎猜了一个意思</p><p>我当时以为 Router 以 URL.Path 调度 Controller 的过程中，每一级的 Controller 和 Path 的名字要一一对应，这个叫做 RESTful 架构，但是现在想想觉得好蠢啊。。</p><h2 id="真正的-RESTful-架构"><a href="#真正的-RESTful-架构" class="headerlink" title="真正的 RESTful 架构"></a>真正的 RESTful 架构</h2><p>阮老师 的博客中已经解释得很清楚了，我再小结一下，也免得自己忘记掉</p><ol><li>资源本身无类型，表现层是什么样取决于需求，就像是 C 语言的内存数据一样，数据本身不会变，表现为什么类型只取决于需求什么类型，所以要注意 Header 中的 Content-Type 哦</li><li>URL.Path 中不能出现动词，应该是分级的名词，版本号也不应出现，要进行的操作应以 Http.Method 来区分</li><li>增删查改 分别对应 POST DELETE GET POST</li></ol><p>当有这些总结之后，再回头看看之前写的那些东西，真的是没眼看</p><blockquote><p>/api/v1/article/add</p></blockquote><p>真是不知道之前怎么能写成这样，这是一次性犯了多少错啊。。。</p><p>所以看了看 RESTful 对自己的提升还是很多的，又要开始重构很多代码了</p>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现简单Shell</title>
      <link href="/2019/409.html"/>
      <url>/2019/409.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-语言实现简单-Shell"><a href="#C-语言实现简单-Shell" class="headerlink" title="C 语言实现简单 Shell"></a>C 语言实现简单 Shell</h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>  buf[MAXLINE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Fork Error !\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Wait Error !\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的原理很简单，循环从标准输入读取命令，读取到之后调用系统函数 execlp 执行命令。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>但是这样其实只能实现无参数调用，如果加参数就会产生错误，像这样</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554896522521-bd50a48e-0eef-43ad-9cb2-4a7d9f3744e2.png" alt="image.png"></p><p>那么想办法来改进一下</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>注意到 其实在调用 exec 系列函数是可以传数组参数的，其中有一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span><span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * __file, <span class="keyword">char</span> * <span class="keyword">const</span> * __argv)</span></span>;</span><br></pre></td></tr></table></figure><p>于是，这样来改进程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>  buf[MAXLINE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        <span class="keyword">char</span>* argv[<span class="number">10</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> args = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buf[len - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将读取到的字符串，解析成参数的数组保存在 argv 中，再传给 execlp</span></span><br><span class="line">        argv[args] = (<span class="keyword">char</span>*)buf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">' '</span> &amp;&amp; buf[i+<span class="number">1</span>] != <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buf[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(buf[i+<span class="number">1</span>] != <span class="string">' '</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    argv[++args] = (<span class="keyword">char</span>*)(buf + i+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// fork 函数 一次调用两次返回，对父进程返回子进程的 pid ，对子进程返回 0，如果返回值小于 0 则表示有错误</span></span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Fork Error !\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            execvp(argv[<span class="number">0</span>], argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Wait Error !\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再演示"><a href="#再演示" class="headerlink" title="再演示"></a>再演示</h2><p>看看改进后的效果，是否可以支持加参数了</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554900459904-1e5d6fa6-5ef1-4357-a386-fa1920853ee4.png" alt="image.png"></p><p>就可以支持参数了，很好嗷</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 问题一记</title>
      <link href="/2019/406.html"/>
      <url>/2019/406.html</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter-环境配置的小问题"><a href="#Flutter-环境配置的小问题" class="headerlink" title="Flutter 环境配置的小问题"></a>Flutter 环境配置的小问题</h1><p>因为之前重置过 Mac 一次，导致我的 Flutter 开发环境没有了，又得重新配置环境，而这个过程，真的是让我很头大，我觉得这甚至可以写进博客，这里可以稍微记录下大体的思路</p><h2 id="下载-Flutter-并添加-bin-到-PATH"><a href="#下载-Flutter-并添加-bin-到-PATH" class="headerlink" title="下载 Flutter 并添加 bin 到 PATH"></a>下载 Flutter 并添加 bin 到 PATH</h2><p>这一步倒是没什么问题，轻车熟路的，一下子就搞定了</p><h2 id="配置-Android-SDK"><a href="#配置-Android-SDK" class="headerlink" title="配置 Android SDK"></a>配置 Android SDK</h2><p>这是最烦的，在这里耗费了不知道多少时间和好心情</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>第一个问题，下载，本来没什么难度，但是。。。</p><p>在 Flutter 的官方文档上有这么一个 Note</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554481707317-e938bb0a-666c-48fb-970e-eb7592538ce5.png" alt="Note"></p><p>翻译一下：Flutter <strong>依赖一个 Android Studio 的完整安装</strong> 来支持它对 Android 平台的依赖，然而，你可以在很多编辑器里写你的 Flutter 应用</p><p>官网说需要一个完整的安装。。但我记得之前好像没有装 Android Studio 也能用啊，这次怎么回事</p><p>那。。到底是下载完整的 Android Studio 呢还是只下载 Command Line Tool 呢</p><p>我选择了后者</p><h3 id="Flutter-doctor"><a href="#Flutter-doctor" class="headerlink" title="Flutter doctor"></a>Flutter doctor</h3><p>Flutter 不认 Android SDK，始终说缺一个 platforms 文件夹，才知道原来这是可以通过 sdkmanager 安装的，于是 执行 sdkmanager 试试，得到了报错。。。网上一查。。。是Java的问题</p><h3 id="Java-版本冲突"><a href="#Java-版本冲突" class="headerlink" title="Java 版本冲突"></a>Java 版本冲突</h3><p>网上查了很久才知道，原来 sdkmanager 只支持 JDK 10 及以下的，但是我之前。。。刚装了 JDK 12。。</p><p>于是，卸载，装 JDK 8</p><p>ps： 为什么是 JDK 8 不是 JDK 10 ？</p><p>ps： 因为 JDK8 可以直接支持 sdkmanager，9 和 10 还要去加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_OPTS=<span class="string">'-XX:+IgnoreUnrecognizedVMOptions --add-modules java.se.ee'</span></span><br></pre></td></tr></table></figure><h3 id="Java-解决方案"><a href="#Java-解决方案" class="headerlink" title="Java 解决方案"></a>Java 解决方案</h3><ol><li>JDK 8 及以下，可直接使用 sdkmanager 安装 Android SDK</li><li>JDK 9 和 JDK 10，需添加环境变量让 sdkmanager 能找到那个模块，然后再正常使用</li><li>JDK 11 和 JDK 12，添加环境变量无作用，因为。。那个包被移除了。。只能装低版本。。。</li></ol><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>最后的，其实挺简单，通过 sdkmanager 安装好 platforms 和 build-tools 之后，添加一个 ANDROID_HOME  就完事了，再执行 flutter doctor 看看，应该就可以识别 SDK 了</p><p>ps：可能还会有证书问题，这个 flutter 给了提示，按提示来可以手动确认证书</p><h2 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h2><p>电脑环境倒是配置好了，手机又出问题了，之前在玩 Island，但似乎它的权限有点过大了，居然把 Android 调试给劫持了，把这个软件里面的一个功能关掉才能正常连接电脑。。。</p><p>然后几分钟后，手机疯狂死机重启。。。</p><p>然后就重装了 Pixel Experience CAF</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>深夜了，环境终于全部搞完，我的三天假期就只剩下两天来做开发，一天都被配这个环境给浪费掉了，从心说一句，垃圾 Java ！自己都不向下兼容，你开发**呢</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Android </tag>
            
            <tag> 小问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探 Kubernetes（二）</title>
      <link href="/2019/3311.html"/>
      <url>/2019/3311.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录一些小问题"><a href="#记录一些小问题" class="headerlink" title="记录一些小问题"></a>记录一些小问题</h1><h2 id="VirtualBox-出现-NS-ERROR-FAILURE-0x80004005-错误"><a href="#VirtualBox-出现-NS-ERROR-FAILURE-0x80004005-错误" class="headerlink" title="VirtualBox 出现 NS_ERROR_FAILURE(0x80004005) 错误"></a>VirtualBox 出现 NS_ERROR_FAILURE(0x80004005) 错误</h2><p>这个问题我是很懵逼的，一开始不知道为什么出现的，经过许多查阅后，得到了几个解法（但是对我的问题没用，似乎这个错误的产生原因有许多）</p><ol><li>重装 VirtualBox</li><li>VirtualBox 文件夹里 改把 vbox 文件删了，重开虚拟机</li><li>卸载重装后，在 设置-隐私和安全 中允许给 VirtualBox 权限</li></ol><p>如果这几个方法解决不了你的问题，那还是自己Google吧</p><p>ps: 我的问题就很厉害了，同样是这个报错，但是百般搜索无果，可能是我动坏了底层的东西，重装系统之后问题解决</p><h2 id="Minukube-启动时-Pull-Image-失败"><a href="#Minukube-启动时-Pull-Image-失败" class="headerlink" title="Minukube 启动时 Pull Image 失败"></a>Minukube 启动时 Pull Image 失败</h2><p>这个问题。。主要还是因为 Kubernetes 是外国的嘛，国内访问的话延迟会比较高或者被 Block，所以解决方案也很简单</p><ol><li>代理</li><li>用国内可以访问的源</li></ol><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理的话，就不用多解释了，一般配置好之后会监听在某个端口上，我们要做的就是让 Minikube 在 Pull Image 的时候走这个端口，直接在终端配置环境变量就行了</p><blockquote><p>export HTTP_PROXY=127.0.0.1:8080<br>export HTTPS_PROXY=127.0.0.1:8080</p></blockquote><p>或者</p><blockquote><p>HTTP_PROXY=127.0.0.1:8080 HTTPS_PROXY=127.0.0.1:8080 minikube start</p></blockquote><h3 id="能访问的源"><a href="#能访问的源" class="headerlink" title="能访问的源"></a>能访问的源</h3><p>这个就比较简单了，DockerHub，就行，虽然还是比较慢，很多 Kubernetes 的镜像在 DockerHub 都有嗷，只要Pull下来改一下 tag 就行了</p><blockquote><p>docker pull mirrorgooglecontainers/kube-apiserver:v1.14.0<br>docker tag mirrorgooglecontainers/kube-apiserver:v1.14.0 k8s.gcr.io/kube-apiserver:1.14.0</p></blockquote><h2 id="Kubernetes-使用-Docker-本地的-Image"><a href="#Kubernetes-使用-Docker-本地的-Image" class="headerlink" title="Kubernetes 使用 Docker 本地的 Image"></a>Kubernetes 使用 Docker 本地的 Image</h2><p>上一篇文章中我提到了一个，没有解释的神奇命令，这里来解释一下</p><p>先说问题和解决方案，再详细描述</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题就是 不知道本地有一个Docker，Minikube 里面还有另外一个 Docker，并不互通</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在执行 <code>docker build</code> 之前，先执行一句 <code>eval $(minikube docker-env)</code> 使 Docker client 连接到 Minikube 中的 Docker daemon 上，之后的操作就可以正常进行了</p><h3 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h3><p>自己写了一个简单的 HelloWorld 服务，打算用 Kubernetes 部署，看到书上讲 Kubernetes 是可以直接使用Docker 镜像的，于是将服务构建成镜像，但没有推送到 Hub 上，打算就在本地供测试使用，万万没想到，出现了一些问题</p><h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><p>构建镜像之后，执行 <code>docker images</code> 能看到镜像构建成功</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554035962870-74984556-e663-4c6f-bb3e-c5a2a0fde779.png" alt="docker images"></p><p>但是在创建 Deployments 后启动 Pod 的时候出现了问题</p><blockquote><p>$ kubectl run hello-go –image=hello-go:v1.0 –port=8080<br>deployment.apps “hello-go” created<br>$ kubectl get pods</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554192581403-b6458b9b-69c1-4813-87f3-d177dc0b8816.png" alt="kubectl get pods"></p><p>结果又出现了错误，实在搞不懂为什么明明本地有镜像 Minikube 却还要去拉取，禁用拉取之后又告诉不行，死活不使用本地的镜像，于是又开始查询，经过了很长时间的查询（可能书上有但我不仔细），才找到了解决方案和原因，<strong>原来 Minikube 自己维护了一个 Docker daemon，可以通过 <code>minikube ssh</code> 命令连接到 Minikube 的 shell ，再执行 <code>docker images</code> 查看 Minikube 内的 Docker 镜像</strong></p><blockquote><p>$ minikube ssh<br>$ docker images</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554194007240-2217cf6d-f9dd-44db-beed-b042d183cf7c.png" alt="docker images"></p><p>可以看到，<strong>原来 Minikube 的本地真的没有 hello-go 镜像，这就很好的解释了为什么它会去拉取镜像，设置为永不拉取之后出现错误的问题了</strong></p><p>知道问题因何而起，那解决起来就简单了</p><p>注意到 Minikube 有一个子命令 docker-env</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554194287519-8c95d777-7d86-4934-a49c-88b711e2f30f.png" alt="minikube"></p><p>执行看看</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554194319879-5a4fbbac-1b3d-497f-92ab-f1708f364b98.png" alt="minikube docker-env"></p><p>给出了 Minikube 内部 Docker daemon 的地址和端口，提示执行 <code>eval $(minikube docker-env)</code> ，照着做就可以使你的 Docker client 直接操作 Minikube 中的 Docker daemon，于是再构建镜像就是保存在 Minikube 中了</p><blockquote><p>$ eval $(minikube docker-env)<br>$ cd ./projectDirectory     // 将工作目录切换到项目文件夹下<br>$ docker build -t hello-go:v1.0 .<br>$ docker images</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554194695441-a57f6a9d-0830-4820-875c-857511f19727.png" alt="docker images"></p><p>这样，就成功构建了镜像并且镜像是保存在 Minikube 中的 Docker 中了，再用 kubectl 创建 deployments</p><blockquote><p>$ kubectl run hello-nice –image=hello-go:v1.0 –port=8080<br>deployment.apps “hello-nice” created<br>$ kubectl get pods</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554194859859-fd9c492f-d9d5-4d01-bb4a-3c8326bbb2c0.png#align=left&amp;display=inline&amp;height=137&amp;name=image.png&amp;originHeight=137&amp;originWidth=675&amp;size=27688&amp;status=done&amp;width=675" alt="kubectl get pods"></p><p>可以看到，不仅新建的 Pods 正常运行了，而且之前因为没有镜像而出错的 Pods 都正常了！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在尝试minikube的过程中笔者就只遇到了这些问题，很庆幸都解决掉了，那这篇文章就记录到这里。</p><p>读者在Minikube使用过程中有什么问题都可以联系笔者噢，说不定可以帮点小忙:)</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小问题 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探 Kubernetes（一）</title>
      <link href="/2019/3310.html"/>
      <url>/2019/3310.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录初探-Kubernetes-的过程"><a href="#记录初探-Kubernetes-的过程" class="headerlink" title="记录初探 Kubernetes 的过程"></a>记录初探 Kubernetes 的过程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一直有想学习 Kubernetes ，最近看了些书，也自己用了用，也遇到了一些小问题，值得写篇博客记录一下</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于笔者仅是自学如何使用 Kubernetes，仅是单机版，还未到部署到生产环境的时候，且使用的是 Mac 电脑，故选择使用 Minikube</p><p>要安装使用 Minikube ，需要先安装 VirtualBox ，以下是一些过程</p><h3 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h3><p><a href="https://www.virtualbox.org" target="_blank" rel="noopener">VirtualBox官网</a> 提供了下载，或者可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/virtualbox/" target="_blank" rel="noopener">清华大学开源软件镜像站</a> 下载</p><p>下载完成之后，打开安装包安装即可</p><h3 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h3><p><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">Minikube</a> 是 Minikube 在 Github 中的项目地址，可以在 Release 标签中找到最新版本下载</p><blockquote><p>$ cd ~/Downloads<br>$ chmod +x ./minikube<br>$ mv ./minikube /usr/local/bin/minikube</p></blockquote><p>这里是给下载的 minikube 加上执行权限后放到 /usr/local/bin 里面，也可以自己选择放在任意 PATH 里</p><p>然后运行测试一下是否安装完成</p><blockquote><p>$ minikube version<br>minikube version: v1.0.0</p></blockquote><p>正确显示出 minikube 的版本，安装成功！</p><h3 id="Kubectl"><a href="#Kubectl" class="headerlink" title="Kubectl"></a>Kubectl</h3><p>Kubectl 是用于控制 Kubernetes 的，可通过包管理程序安装(Mac 用 brew ，Centos 用 yum，Ubuntu 用 apt)</p><blockquote><p>$ brew install kubernetes-cli<br>$ kubectl<br>kubectl controls the Kubernetes cluster manager.</p><p>Find more information at: <a href="https://kubernetes.io/docs/reference/kubectl/overview/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/kubectl/overview/</a><br>…</p></blockquote><p>安装成功，接下来可以准备启动了</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><blockquote><p>$ minikube start<br>😄  minikube v1.0.0 on darwin (amd64)<br>🤹  Downloading Kubernetes v1.14.0 images in the background …<br>💡  Tip: Use ‘minikube start -p <name>‘ to create a new cluster, or ‘minikube delete’ to delete this one.<br>🏃  Re-using the currently running virtualbox VM for “minikube” …<br>⌛  Waiting for SSH access …<br>📶  “minikube” IP address is 192.168.99.104<br>🐳  Configuring Docker as the container runtime …<br>🐳  Version of container runtime is 18.06.2-ce<br>⌛  Waiting for image downloads to complete …<br>✨  Preparing Kubernetes environment …<br>🚜  Pulling images required by Kubernetes v1.14.0 …<br>🔄  Relaunching Kubernetes v1.14.0 using kubeadm …<br>⌛  Waiting for pods: apiserver proxy etcd scheduler controller dns<br>📯  Updating kube-proxy configuration …<br>🤔  Verifying component health …..<br>💗  kubectl is now configured to use “minikube”<br>🏄  Done! Thank you for using minikube!</name></p><p>$ kubectl get nodes</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554018821347-c95d911f-88cb-4a73-b226-c425a84932e8.png" alt="kubectl get pods"></p><p>可以看到， minikube 启动成功之后，用 <code>kubectl get nodes</code> 可以成功获取到 nodes 的信息，一切正常！</p><h2 id="写一个小服务，尝试部署"><a href="#写一个小服务，尝试部署" class="headerlink" title="写一个小服务，尝试部署"></a>写一个小服务，尝试部署</h2><h3 id="Hello-World-代码"><a href="#Hello-World-代码" class="headerlink" title="Hello World 代码"></a>Hello World 代码</h3><p>此处采用Go语言，因为可以静态编译且语法简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">fmt.Println(<span class="string">"Listening on http://localhost:8080/"</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello World"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>$ go run main.go<br>Listening on <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p></blockquote><p>用浏览器打开上面的网址可以看到</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554013868546-bc0e4859-0672-4173-9b5b-99326c52373d.png" alt="浏览器访问"></p><p>成功输出了 Hello World</p><p>下一步</p><h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><p>可能有人会问会什么要静态编译，不能直接 <code>go run main.go</code> 吗</p><p>如果用 <code>go run main.go</code> 来启动服务，那么还需要 Go 语言的开发环境，如果代码复杂一点还需要安装各种依赖库，会导致镜像过于庞大，因为这只是一个很小很简单的 Demo ，仅作测试的小玩具，静态编译出的可执行文件最大不到 10MB ，而为了不编译直接运行所需要的开发环境，至少都是 几百MB ，没有必要为了一个小 Demo 去浪费那么多资源，所以选择静态编译</p><blockquote><p>$ GOOS=linux CGO_ENABLED=0 go build -o main -ldflags ‘-extldflags “-static”‘ main.go</p></blockquote><p>执行这条命令后可以看到当前目录下多了一个名为 main 的可执行文件</p><p>但是不能执行，因为当前是 MacOS 环境，而静态编译时指定的是 Linux 环境</p><p>ps: 如果读者是 Linux 环境当我没说</p><p>ps: 如果有读者看不懂这条命令，没关系不要怕，你不是不懂 Golang ，你只是不懂 C 而已</p><h3 id="构建-Docker-镜像"><a href="#构建-Docker-镜像" class="headerlink" title="构建 Docker 镜像"></a>构建 Docker 镜像</h3><p>要构建 Docker 镜像，我们先写一个 dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./main /main</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"/main"</span> ]</span></span><br></pre></td></tr></table></figure><p>ps: scratch 是一个空的 Docker 镜像，即不使用基础镜像的意思</p><p>写好 Dockerfile 后，在执行命令构建镜像之前，要确保minikube已经启动，并且执行一句神奇的命令先</p><blockquote><p>$ eval $(minikube docker-env)</p></blockquote><p>在这条命令里藏着我半天的心酸，下一篇文章会仔细解释，这里先不作解释</p><p>再执行下面这些</p><blockquote><p>$ docker build -t hello:v1.0 .<br>Sending build context to Docker daemon  11.73MB<br>Step 1/3 : FROM scratch<br>—&gt;<br>Step 2/3 : ADD ./main /main<br>—&gt; 636350b5d281<br>Step 3/3 : CMD [ “/main” ]<br>—&gt; Running in a54d3c9c3864<br>Removing intermediate container a54d3c9c3864<br>—&gt; 321b69c05fff<br>Successfully built 321b69c05fff<br>Successfully tagged hello:v1.0<br>$ docker images</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554018896187-c9afeaca-2042-42c8-aaf0-7ad775eb1c33.png" alt="docker images"></p><p>可以看到，成功地构建了镜像，笔者这里镜像大小仅仅只有 7.34MB</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>部署分为两个步骤</p><h4 id="创建-Deployments-和-Pods"><a href="#创建-Deployments-和-Pods" class="headerlink" title="创建 Deployments 和 Pods"></a>创建 Deployments 和 Pods</h4><blockquote><p>$ kubectl run hello –image=hello:v1.0 –port=8080<br>deployment.apps “hello” created<br>$ kubectl get deployments</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554018939941-8516aaf8-b734-40ba-9e1c-4e1d66699988.png" alt="kubectl get deployments"></p><blockquote><p>$ kubectl get pods</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554018967294-676d6ced-c2aa-4e43-8005-414c1e165a13.png" alt="kubectl get pods"></p><p>可以看到，Pods 已经准备好了</p><h4 id="创建-Service-以供外部访问"><a href="#创建-Service-以供外部访问" class="headerlink" title="创建 Service 以供外部访问"></a>创建 Service 以供外部访问</h4><blockquote><p>$ kubectl expose deployment hello –port=8080 –type=NodePort<br>service “hello” exposed<br>$ kubectl get services</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554018998759-1009c3b7-d614-4b01-85fe-6a23fe758bdc.png" alt="kubectl get services"></p><p>可以看到，service 已经创建成功，执行以下命令来查看 service 的 ip 和端口</p><p>ps: ip和端口以自己执行命令后输出的为准</p><blockquote><p>$ minikube service hello –url<br><a href="http://192.168.99.104:31537" target="_blank" rel="noopener">http://192.168.99.104:31537</a><br>$ curl <a href="http://192.168.99.104:31537" target="_blank" rel="noopener">http://192.168.99.104:31537</a><br>Hello World</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/162233/1554017653231-56204059-016c-485a-bd07-7c6d3e6ce782.png" alt="浏览器访问"></p><p>使用浏览器打开，可以看到输出 Hello World，部署一切正常！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在部署的过程中其实遇到了很多困难，我会在接下来的一篇文章中详细说明，如果有遇到相同困难的朋友可以参考参考</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> 新开始 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2019/323.html"/>
      <url>/2019/323.html</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这是我的第一篇博客哦</p><p>刚搭建好环境，接下来就可以好好写文章啦</p><p>以后预计每周至少两篇博客，内容包括但不限于 编程经验，读书笔记，好词句积累，随笔</p><p>毕竟，这里是我的博客，独属于我自己，那就随意一点喽 :)</p>]]></content>
      
      
      <categories>
          
          <category> 杂言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新开始 </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
